# Quest 12. 보안의 기초

## Introduction
* 이번 퀘스트에서는 가장 기초적인 웹 서비스 보안에 대해 알아보겠습니다.

## Topics
* XSS, CSRF, SQL Injection
* HTTPS, TLS

## Resources
* [The Basics of Web Application Security](https://martinfowler.com/articles/web-security-basics.html)
* [Website Security 101](https://spyrestudios.com/web-security-101/)
* [Web Security Fundamentals](https://www.shopify.com.ng/partners/blog/web-security-2018)
* [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
* [Wikipedia - TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security)

## Checklist
* 입력 데이터의 Validation을 웹 프론트엔드에서 했더라도 서버에서 또 해야 할까요? 그 이유는 무엇일까요?
```
예, 입력 데이터의 유효성 검사는 웹 프런트 엔드에서 유효성을 검사한 경우에도 서버에서 다시 수행해야 합니다. 웹 프런트 엔드에서 발생하는 클라이언트 측 유효성 검사는 악의적인 사용자가 쉽게 우회하거나 조작할 수 있기 때문입니다. 클라이언트 측 유효성 검사는 사용자의 브라우저에서 실행되는 JavaScript 및 기타 기술에 의존하며 악의적인 의도를 가진 사용자가 비활성화하거나 수정할 수 있습니다.

반면에 서버 측 유효성 검사는 데이터의 실제 처리 및 저장이 발생하는 서버에서 수행됩니다. 클라이언트에서 보낸 데이터를 처리하거나 저장하기 전에 유효성을 검사하여 추가 보안 계층을 제공합니다. 서버 측 유효성 검사는 승인되지 않은 데이터나 악의적인 데이터가 서버에서 승인 및 처리되는 것을 방지하여 유효하고 안전한 데이터만 승인되고 처리되도록 합니다.

또한 클라이언트 측 유효성 검사에만 의존하면 클라이언트마다 유효성 검사 로직의 구현이나 버전이 다를 수 있으므로 데이터 무결성의 불일치가 발생할 수 있습니다. 서버 측 유효성 검사는 모든 클라이언트에서 일관되고 표준화된 유효성 검사 프로세스를 보장하여 데이터 불일치의 위험을 줄입니다.

요약하면 클라이언트 측 유효성 검사는 편리하고 사용자 친화적인 경험을 제공할 수 있지만 유일한 유효성 검사 메커니즘으로 의존해서는 안 됩니다. 서버 측 유효성 검사는 데이터 무결성을 보장하고 악의적인 활동을 방지하며 여러 클라이언트에서 일관된 유효성 검사 프로세스를 유지하는 데 필수적입니다.
```
  * 서버로부터 받은 HTML 내용을 그대로 검증 없이 프론트엔드에 innerHTML 등을 통해 적용하면 어떤 문제점이 있을까요?
  ```
  서버에서 받은 HTML 콘텐츠가 적절한 유효성 검사 없이 innerHTML을 통해 프런트 엔드에 적용되면 다음과 같은 몇 가지 문제가 발생할 수 있습니다.
  
  1. XSS(Cross-Site Scripting) 공격: 유효성 검사가 없으면 서버는 잠재적으로 HTML 콘텐츠의 일부로 악성 스크립트가 포함된 악성 HTML 코드를 보낼 수 있습니다. 이 HTML을 innerHTML을 사용하여 프런트 엔드에 직접 적용하면 스크립트가 사용자의 브라우저에서 실행되어 XSS 공격이 발생할 수 있습니다. 이로 인해 공격자는 사용자를 대신하여 악성 코드를 삽입하거나 중요한 정보를 도용하거나 기타 승인되지 않은 작업을 수행할 수 있습니다.
  2. 코드 주입 공격: 서버 측 유효성 검사가 수행되지 않으면 HTML 콘텐츠에 SQL 또는 JavaScript 코드와 같은 승인되지 않은 코드가 포함되어 프런트 엔드 애플리케이션에 주입될 수 있습니다. 이로 인해 공격자가 애플리케이션의 백엔드 데이터베이스에서 데이터를 조작 또는 검색하거나 사용자 브라우저에서 임의의 코드를 실행할 수 있는 코드 삽입 공격이 발생할 수 있습니다.
  3. 깨진 HTML 구조: 수신된 HTML 콘텐츠에 형식이 잘못되었거나 유효하지 않은 HTML이 포함되어 있는 경우 유효성 검사 없이 프런트 엔드에 적용하면 HTML 구조가 깨질 수 있습니다. 이로 인해 프런트 엔드 애플리케이션에서 렌더링 문제, 손상된 기능 또는 예기치 않은 동작이 발생할 수 있습니다.
  4. 데이터 무결성 문제: 유효성 검사가 없으면 수신된 HTML 콘텐츠가 예상 데이터 형식 또는 구조를 준수하지 않을 수 있습니다. 이로 인해 부정확하거나 일관성 없는 데이터를 표시하거나 유효하지 않은 데이터를 서버에 저장하는 등의 데이터 무결성 문제가 발생할 수 있습니다.
  5. 보안 취약성: 서버에서 받은 HTML 콘텐츠의 유효성을 검사하지 않으면 잠재적인 보안 취약성이 눈에 띄지 않아 프런트 엔드 애플리케이션의 잠재적 악용 또는 취약성이 발생할 수 있습니다.
  
  요약하면 innerHTML을 사용하여 프런트 엔드에 적용하기 전에 서버에서 받은 HTML 콘텐츠의 적절한 유효성 검사를 수행하지 않으면 프런트 엔드 애플리케이션에서 보안 위험, 데이터 무결성 문제 및 기타 예기치 않은 동작이 발생할 수 있습니다. 프런트 엔드 애플리케이션의 무결성과 보안을 보장하려면 강력한 서버 측 유효성 검사를 구현하는 것이 중요합니다.
  ```
  * XSS(Cross-site scripting)이란 어떤 공격기법일까요?
  ```
  XSS(Cross-Site Scripting)는 악성 스크립트가 웹사이트 또는 웹 애플리케이션에 삽입되고 이러한 스크립트가 영향을 받는 웹사이트를 방문하는 다른 사용자의 브라우저에서 실행되는 웹 기반 공격 기술의 한 유형입니다. XSS 공격은 응용 프로그램이 입력 필드 또는 주석과 같은 사용자 생성 콘텐츠를 적절한 유효성 검사 또는 삭제 없이 웹 페이지에 포함하도록 허용할 때 발생합니다.
  
  XSS 공격은 세 가지 주요 유형으로 분류할 수 있습니다.
  
  1. Reflected XSS: 이 유형의 XSS 공격에서는 웹 서버로 전송되는 URL 또는 양식 데이터에 악성 스크립트가 포함됩니다. 서버는 악성 스크립트를 사용자의 브라우저에 다시 반영한 다음 스크립트를 실행합니다. 이러한 유형의 XSS 공격은 일반적으로 악의적인 링크로 특정 사용자를 대상으로 하거나 사용자로부터 중요한 정보를 훔치는 데 사용됩니다.
  2. 저장된 XSS: 이 유형의 XSS 공격에서는 악의적인 스크립트가 웹 서버(일반적으로 데이터베이스)에 저장되고 나중에 영향을 받는 페이지에 액세스할 때 다른 사용자에게 표시됩니다. 이러한 유형의 XSS 공격은 여러 사용자에게 영향을 미치고 악의적인 스크립트를 지속적으로 실행하여 잠재적인 데이터 도난, 무단 작업 또는 기타 악의적인 활동을 유발할 수 있으므로 특히 위험합니다.
  3. DOM 기반 XSS: 이 유형의 XSS 공격에서는 악의적인 스크립트가 서버로 전송되지 않고 웹 페이지의 DOM(문서 개체 모델)의 클라이언트 측에서 주입 및 실행됩니다. 이러한 유형의 XSS 공격은 일반적으로 사용자 생성 데이터가 적절한 유효성 검사나 인코딩 없이 DOM에 직접 포함될 수 있도록 허용하는 안전하지 않은 JavaScript 코딩 방식으로 인해 발생합니다.
  
  XSS 공격은 민감한 정보 도용, 사용자 계정에 대한 무단 액세스, 맬웨어 또는 바이러스 확산, 웹사이트 콘텐츠 손상 또는 조작 등 심각한 결과를 초래할 수 있습니다. XSS 공격을 방지하고 이러한 유형의 취약성으로부터 웹 응용 프로그램을 보호하려면 적절한 입력 유효성 검사, 출력 인코딩 및 기타 보안 조치를 구현해야 합니다.
  ```
  * CSRF(Cross-site request forgery)이란 어떤 공격기법일까요?
  ```
  CSRF(Cross-Site Request Forgery)는 악의적인 웹 사이트가 사용자의 브라우저를 속여 사용자가 인증된 다른 웹 사이트에 무단 요청을 하도록 하는 웹 기반 공격 기술의 한 유형입니다. CSRF 공격은 웹사이트가 사용자의 인증된 세션에서 갖고 있는 신뢰를 악용하여 사용자 대신 무단 작업을 수행합니다.
  
  CSRF 공격에서 피해자는 일반적으로 악의적인 웹 사이트를 방문하거나 악의적인 링크를 클릭하도록 유인됩니다. 그런 다음 악성 웹사이트는 피해자의 자격 증명과 피해자의 브라우저에 저장된 세션 쿠키를 사용하여 피해자가 인증된 다른 웹사이트에 승인되지 않은 요청을 보냅니다. 이러한 무단 요청은 피해자가 알지 못하거나 동의하지 않은 상태에서 피해자의 비밀번호 변경, 구매 또는 계정 설정 수정과 같은 작업을 수행할 수 있습니다.
  CSRF 공격은 이미지 태그, 스크립트 태그, 숨겨진 양식 또는 XMLHttpRequests를 포함하여 다양한 방식으로 수행될 수 있습니다. 공격자가 피해자의 데이터를 직접 조작하거나 피해자 시스템의 취약점을 악용하도록 요구하지 않고 대신 다른 웹 사이트에서 피해자의 활성 세션에 의존합니다.
  CSRF 공격을 방지하기 위해 웹 애플리케이션은 CSRF 토큰 사용, Referer 헤더 확인, 쿠키에 대한 Same-Site 속성 구현과 같은 적절한 안티 CSRF 방어를 구현해야 합니다. 이러한 방어는 웹 사이트에 대한 요청이 합법적이고 악의적인 제3자 웹 사이트가 아닌 웹 사이트에서 인증된 동일한 사용자에 의해 시작되도록 하는 데 도움이 될 수 있습니다.
  CSRF 공격은 사용자 계정에 대한 무단 작업, 데이터 변조 및 재정적 손실을 포함하여 심각한 결과를 초래할 수 있습니다. CSRF 취약성으로부터 보호하고 웹 애플리케이션의 무결성과 보안을 보호하기 위해 적절한 보안 조치를 구현해야 합니다.
  ```
  * SQL Injection이란 어떤 공격기법일까요?
  ```
  SQL 인젝션은 악성 SQL(Structured Query Language) 쿼리를 웹 애플리케이션의 입력 필드나 매개변수에 인젝션한 다음 적절한 검증이나 삭제 없이 기본 데이터베이스 관리 시스템(DBMS)에 의해 실행되는 웹 기반 공격 기술의 한 유형입니다. SQL 삽입 공격은 사용자 생성 입력 처리의 취약점을 악용하여 공격자가 데이터베이스에서 데이터를 조작 또는 검색하거나 데이터를 수정 또는 삭제하거나 임의의 SQL 명령을 실행할 수 있도록 합니다.
  SQL 인젝션 공격은 다음과 같은 다양한 형태로 발생할 수 있습니다.
  1. 인밴드 SQL 인젝션: 이러한 유형의 SQL 인젝션 공격에서는 인젝션된 SQL 쿼리의 결과가 애플리케이션의 응답에 직접 표시됩니다. 애플리케이션이 적절한 유효성 검사나 인코딩 없이 사용자 입력을 반향하여 공격자가 데이터를 검색하거나 임의의 SQL 명령을 실행할 수 있는 경우 이러한 상황이 발생할 수 있습니다.
  2. 블라인드 SQL 인젝션: 이 유형의 SQL 인젝션 공격에서는 인젝션된 SQL 쿼리의 결과가 애플리케이션의 응답에 직접 표시되지 않습니다. 공격자는 오류 메시지, 타이밍 지연 또는 기타 단서와 같은 다른 수단을 통해 쿼리 결과를 유추해야 할 수 있습니다.
  3. 대역 외 SQL 주입: 이러한 유형의 SQL 주입 공격에서 공격자는 주입된 SQL 쿼리의 결과를 애플리케이션의 응답으로 직접 수신하지 않습니다. 대신 공격자는 이메일 또는 DNS 요청과 같은 다른 통신 채널을 사용하여 쿼리 결과를 검색할 수 있습니다.
  
  SQL 주입 공격은 민감한 데이터에 대한 무단 액세스, 데이터 조작 또는 삭제, 기본 데이터베이스 서버의 완전한 손상을 포함하여 심각한 결과를 초래할 수 있습니다. SQL 인젝션 취약점을 방지하고 이러한 유형의 공격으로부터 웹 애플리케이션을 보호하려면 적절한 입력 유효성 검사, 매개 변수화된 쿼리 및 기타 보안 조치를 구현해야 합니다.
  ```

* 대부분의 최신 브라우저에서는 HTTP 대신 HTTPS가 권장됩니다. 이유가 무엇일까요?
```
HTTPS(Hypertext Transfer Protocol Secure)는 다음과 같은 몇 가지 이유로 대부분의 최신 브라우저에서 HTTP(Hypertext Transfer Protocol)보다 권장됩니다.

1. 데이터 보안: HTTPS는 웹 브라우저와 웹 서버 간에 교환되는 데이터를 암호화하여 가로채는 사람이 데이터를 읽을 수 없도록 합니다. 이렇게 하면 로그인 자격 증명, 신용 카드 세부 정보 및 기타 개인 데이터와 같은 민감한 정보가 전송 중에 가로채거나 변조되지 않도록 보호할 수 있습니다.
2. 인증 및 신뢰: HTTPS는 디지털 인증서를 사용하여 웹 서버의 ID를 인증하여 사용자가 사기성 웹사이트가 아닌 합법적인 웹사이트와 통신하고 있음을 확인할 수 있는 방법을 제공합니다. 이는 전자 상거래 사이트, 온라인 뱅킹 및 민감한 정보를 처리하는 기타 웹 사이트에 특히 중요한 웹 사이트의 신뢰성에 대한 신뢰와 신뢰를 구축하는 데 도움이 됩니다.
3. 검색 엔진 순위: Google을 포함한 많은 검색 엔진은 검색 순위에서 HTTP보다 HTTPS를 사용하는 웹사이트를 우선 순위에 둡니다. 즉, HTTPS를 사용하는 웹사이트는 검색 결과에서 더 높은 위치에 표시될 가능성이 더 높으며 잠재적으로 가시성과 트래픽이 증가할 수 있습니다.
4. 브라우저 지원: Chrome, Firefox, Safari 및 Edge를 포함한 대부분의 최신 웹 브라우저는 위치 정보, 카메라/마이크 액세스 및 푸시 알림과 같은 특정 기능에 대해 HTTPS 사용을 강력히 권장하거나 요구합니다. HTTP를 사용하는 웹사이트는 이러한 기능에 액세스할 때 제한 또는 제약이 발생할 수 있습니다.
5. 산업 표준 및 규정 준수: HTTPS는 신용 카드 정보를 처리하기 위한 PCI DSS(Payment Card Industry Data Security Standard) 및 개인 정보 보호를 위한 GDPR(General Data Protection Regulation)과 같은 산업 표준 및 규정에서 요구하거나 권장하는 경우가 많습니다. 유럽 ​​연합의 사용자 데이터.

전반적으로 HTTPS는 향상된 보안, 인증, 신뢰, 검색 엔진 순위, 브라우저 지원 및 업계 표준 준수를 제공하므로 인터넷을 통해 전송되는 데이터의 기밀성, 무결성 및 신뢰성을 보장하기 위해 최신 웹 브라우징에 권장되는 선택입니다.
```
  * HTTPS와 TLS는 어떤 식으로 동작하나요? HTTPS는 어떤 역사를 가지고 있나요?
  ```
  HTTPS(Hypertext Transfer Protocol Secure)는 인터넷을 통한 통신에 사용되는 HTTP(Hypertext Transfer Protocol)의 보안 버전입니다. HTTPS는 암호화를 사용하여 웹 브라우저와 웹 서버 간에 전송되는 데이터를 보호하여 기밀성, 무결성 및 신뢰성을 보장합니다. TLS(전송 계층 보안)는 HTTPS가 보안 통신에 사용하는 암호화 프로토콜입니다.
  
  HTTPS 및 TLS 작동 방식은 다음과 같습니다.
  1. 핸드셰이크: 사용자가 HTTPS로 웹 사이트에 액세스하려고 하면 웹 서버는 공개 키가 포함된 디지털 인증서를 웹 브라우저에 제공합니다. 그런 다음 웹 브라우저는 인증서의 진위를 확인하고 웹 서버와의 보안 연결을 설정합니다.
  2. 암호화: 보안 연결이 설정되면 웹 브라우저와 웹 서버 간에 교환되는 데이터는 대칭 또는 비대칭 암호화 알고리즘을 사용하여 암호화됩니다. 이렇게 하면 데이터가 인터넷을 통해 이동할 때 데이터에 대한 무단 액세스를 방지할 수 있습니다.
  3. 데이터 전송: 암호화된 데이터는 웹 브라우저와 웹 서버 간에 전송되어 기밀성과 무결성을 보장합니다. 웹 브라우저는 웹 서버로부터 받은 데이터를 복호화하고, 웹 서버는 웹 브라우저로 보낸 데이터를 암호화합니다.
  4. 인증: TLS는 또한 인증을 제공하여 웹 서버가 사기꾼이 아닌 합법적인지 확인합니다. 이는 웹 서버의 ID를 확인하는 신뢰할 수 있는 인증 기관(CA)에서 발행한 디지털 인증서를 통해 이루어집니다.
  HTTPS의 역사는 Netscape Communications Corporation이 온라인 통신을 보호하는 방법으로 HTTPS를 도입한 1990년대 중반으로 거슬러 올라갑니다. HTTPS의 원래 버전은 암호화 및 인증을 위해 SSL(Secure Sockets Layer)이라는 프로토콜을 사용했습니다. 나중에 SSL은 인터넷을 통한 보안 통신을 위한 현재 산업 표준인 TLS로 대체되었습니다.
  수년 동안 HTTPS는 웹 통신 보안을 위한 사실상의 표준이 되었으며 로그인 자격 증명, 신용 카드 세부 정보 및 개인 데이터와 같은 중요한 정보를 보호하는 데 널리 사용됩니다. 많은 웹사이트, 특히 민감한 정보를 다루는 웹사이트는 인터넷을 통해 전송되는 데이터의 기밀성, 무결성 및 신뢰성을 보장하기 위해 HTTPS 사용을 요구하거나 권장합니다.
  ```
  * HTTPS의 서비스 과정에서 인증서는 어떤 역할을 할까요? 인증서는 어떤 체계로 되어 있을까요?
  ```
  인증서는 HTTPS 서비스 프로세스에서 중요한 역할을 합니다. 웹 서버의 ID를 인증하고 웹 브라우저와 웹 서버 간의 보안 통신을 설정하는 데 사용됩니다. 인증서 시스템에는 몇 가지 주요 구성 요소가 포함됩니다.
  
  1. 인증 기관(CA): 인증 기관은 디지털 인증서를 발급하는 신뢰할 수 있는 엔터티입니다. CA는 웹 서버 ID의 진위를 확인하고 적법성을 증명하는 디지털 인증서를 발행할 책임이 있습니다.
  2. 디지털 인증서: 디지털 인증서는 도메인 이름, 공개 키 및 기타 관련 세부 정보와 같은 웹 서버의 ID에 대한 정보가 포함된 디지털 문서입니다. 인증 기관에서 발행하고 무결성을 보장하기 위해 디지털 서명됩니다.
  3. 공개 키: 공개 키는 HTTPS에서 사용되는 비대칭 암호화 알고리즘의 일부입니다. 디지털 인증서에 포함되어 있으며 웹 브라우저에서 웹 서버로 전송되는 데이터를 암호화하는 데 사용됩니다.
  4. 개인 키: 개인 키는 공개 키에 대응하며 웹 서버에 의해 비밀로 유지됩니다. 해당 공개 키로 암호화된 데이터를 복호화하는 데 사용됩니다. 개인 키를 소유한 웹 서버만이 데이터를 해독할 수 있으므로 기밀성이 보장됩니다.
  5. 핸드셰이크: TLS 핸드셰이크 프로세스 중에 웹 서버는 웹 브라우저에 디지털 인증서를 제공합니다. 그런 다음 웹 브라우저는 신뢰할 수 있는 루트 인증서로 웹 브라우저에 미리 설치된 CA의 공개 키를 사용하여 인증서의 진위를 확인합니다. 인증서가 유효한 경우 웹 브라우저와 웹 서버는 암호화된 통신을 위한 보안 연결을 설정합니다.
 
  HTTPS의 인증서 시스템은 웹 브라우저와 웹 서버 간에 신뢰와 인증을 설정하는 데 도움이 됩니다. 웹 서버가 합법적이고 웹 서버와 웹 브라우저 간에 전송되는 데이터가 암호화되고 안전하도록 보장합니다. 신뢰할 수 있는 인증 기관에서 발급한 디지털 인증서는 HTTPS의 보안 통신 프로세스에서 중요한 역할을 합니다.
  ```
## Quest
* 메모장의 서버와 클라이언트에 대해, 로컬에서 발행한 인증서를 통해 HTTPS 서비스를 해 보세요.

## Advanced
* TLS의 인증서에 쓰이는 암호화 알고리즘은 어떤 종류가 있을까요?
* HTTP/3은 기존 버전과 어떻게 다를까요? HTTP의 버전 3이 나오게 된 이유는 무엇일까요?
