# Quest 15. 자동화된 테스트

## Introduction
* 이번 퀘스트에서는 자동화된 테스트에 어떤 장점이 있는지, 어떤 식으로 구축할 수 있는지에 대해 알아보겠습니다.

## Topics
* Automated Test
  * TDD
  * Unit Test
  * Integration Test
  * E2E Test
  * Stub & Mock
* Jest
* Puppeteer

## Resources
* [Unit Test (단위 테스트) 도입하기](https://www.popit.kr/unit-test-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-1%ED%8E%B8/)
* [소프트웨어 테스트 안티 패턴](https://velog.io/@leejh3224/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%95%88%ED%8B%B0-%ED%8C%A8%ED%84%B4)
* [End-to-End testing with Puppeteer and Jest](https://medium.com/touch4it/end-to-end-testing-with-puppeteer-and-jest-ec8198145321)
* [Mock & Stub](https://stackoverflow.com/questions/3459287/whats-the-difference-between-a-mock-stub)

## Checklist
* 자동화된 테스트를 만드는 것에는 어떤 장점과 단점이 있을까요?
```
자동화된 테스트 또는 테스트 자동화라고도 하는 자동화된 테스트는 소프트웨어 애플리케이션 또는 시스템에 대한 테스트를 자동으로 실행하는 코드 작성과 관련된 소프트웨어 개발 방식입니다. 다음은 자동화된 테스트 생성의 장단점입니다.

자동화 테스트의 장점:

1. 향상된 소프트웨어 품질: 자동화된 테스트를 통해 버그, 오류 및 회귀가 생산 단계로 들어가기 전에 개발 프로세스 초기에 발견할 수 있습니다. 결과적으로 문제를 신속하게 식별하고 수정하여 소프트웨어 품질을 개선하고 결함이 있는 소프트웨어를 출시할 가능성을 줄입니다.
2. 더 빠르고 효율적인 테스트: 자동화된 테스트를 반복적이고 일관되게 실행할 수 있으므로 소프트웨어 애플리케이션 또는 시스템을 빠르고 효율적으로 테스트할 수 있습니다. 이렇게 하면 시간이 많이 걸리고 사람이 실수하기 쉬운 수동 테스트에 비해 시간과 노력이 절약됩니다.
3. 증가된 테스트 범위: 자동화된 테스트는 극단적인 경우와 복잡한 상호 작용을 포함하여 수동으로 테스트할 수 없는 많은 테스트 시나리오를 다룰 수 있습니다. 이를 통해 더 높은 테스트 범위를 달성하고 소프트웨어의 다른 부분을 철저히 테스트할 수 있습니다.
4. 회귀 조기 감지: 코드베이스를 변경한 후 자동화된 테스트를 쉽게 다시 실행할 수 있으므로 회귀, 즉 새로운 버그를 도입하거나 기존 기능을 손상시키는 의도하지 않은 변경을 조기에 감지할 수 있습니다. 이렇게 하면 회귀 문제가 눈에 띄지 않게 되는 것을 방지하고 소프트웨어를 안정적이고 신뢰할 수 있게 유지할 수 있습니다.
5. 빠른 출시 시간: 자동화된 테스트를 통해 문제를 조기에 파악하여 소프트웨어 릴리스에 대한 빠른 버그 수정 및 처리 시간을 단축할 수 있습니다. 이를 통해 소프트웨어 애플리케이션 또는 시스템의 시장 출시 시간을 단축하여 조직에 경쟁 우위를 제공합니다.

자동화 테스트의 단점:

1. 시간과 노력의 초기 투자: 자동화된 테스트를 만들고 유지 관리하려면 테스트 프레임워크를 설정하고 테스트 스크립트를 작성하고 소프트웨어가 발전함에 따라 유지 관리하기 위한 초기 시간과 노력이 필요합니다. 이것은 특히 복잡한 응용 프로그램이나 시스템의 경우 까다롭고 시간이 많이 소요될 수 있습니다.
2. 유지 관리 오버헤드: 자동 테스트는 사용자 인터페이스의 업데이트 또는 기본 기술 스택의 변경과 같은 소프트웨어 변경 사항을 최신 상태로 유지하기 위해 정기적인 유지 관리가 필요할 수 있습니다. 이로 인해 시간, 노력 및 리소스 측면에서 오버헤드가 추가될 수 있습니다.
3. 가양성 및 거짓음성: 자동화된 테스트는 소프트웨어가 실제로 올바르게 작동할 때 오류를 나타내는 가양성 또는 실제 문제를 감지하지 못하는 가음성을 생성할 수 있습니다. 이로 인해 잘못된 결과를 조사하고 해결하는 데 시간과 노력이 낭비될 수 있습니다.
4. 인간의 판단이 제한됨: 자동 테스트는 미리 정의된 스크립트를 기반으로 하며 수동 테스트가 제공할 수 있는 인간의 판단과 직관이 부족할 수 있습니다. 소프트웨어 테스트의 일부 복잡한 시나리오 또는 주관적인 측면은 정확한 평가를 위해 사람의 개입이 필요할 수 있습니다.
5. 모든 것을 테스트할 수 없음: 자동화된 테스트는 많은 시나리오를 다룰 수 있지만 특히 소프트웨어가 매우 복잡하거나 동적 동작이 있는 경우 모든 것을 테스트하지 못할 수 있습니다. 특정 유형의 문제를 발견하려면 여전히 수동 테스트가 필요할 수 있습니다.

결론적으로 자동화된 테스트는 소프트웨어 품질 향상, 더 빠르고 효율적인 테스트, 테스트 적용 범위 증가, 회귀 조기 감지와 같은 많은 이점을 제공합니다. 그러나 초기 시간과 노력의 투자, 지속적인 유지 관리가 필요하며 잘못된 결과 및 인간의 판단 측면에서 한계가 있을 수 있습니다. 조직은 소프트웨어 개발 사례의 일부로 자동화된 테스트를 채택하기로 결정하기 전에 특정 요구 사항과 리소스를 신중하게 고려해야 합니다.
```
  * TDD(Test-Driven Development)란 무엇인가요? TDD의 장점과 단점은 무엇일까요?
  ```
  TDD(Test-Driven Development)는 소프트웨어 기능을 구현하기 위한 코드를 작성하기 전에 소프트웨어 기능에 대한 테스트를 작성하는 소프트웨어 개발 접근 방식입니다. TDD의 개발 프로세스는 일반적으로 다음 단계를 따릅니다.
  
  1. 테스트 작성: 개발자는 소프트웨어가 표시해야 하는 특정 기능 또는 동작에 대한 테스트 케이스를 작성합니다.
  2. 테스트 실행: 테스트가 실행되고 기능을 구현하는 코드가 아직 작성되지 않았기 때문에 처음에는 실패해야 합니다.
  3. 코드 작성: 개발자는 테스트에서 확인하는 기능을 구현하기 위한 코드를 작성합니다.
  4. 테스트 다시 실행: 테스트가 다시 실행되고 구현된 코드가 올바른 경우 통과해야 합니다.
  5. 리팩터링: 개발자는 코드를 리팩터링하여 개선하거나 최적화하면서 테스트가 계속 통과되도록 합니다.
  6. 반복: 구현해야 하는 각각의 새로운 기능이나 동작에 대해 프로세스가 반복됩니다.
  
  테스트 주도 개발(TDD)의 장점:
  
  1. 개선된 코드 품질: TDD는 코드가 예상 요구 사항을 충족하고 정의된 테스트에 따라 올바르게 작동하는지 확인하는 데 도움이 됩니다. 그 결과 코드 품질이 향상되고 버그나 회귀가 발생할 가능성이 줄어듭니다.
  2. 빠른 버그 감지 및 수정: TDD는 코드를 작성하기 전에 테스트를 작성하여 개발 프로세스 초기에 버그를 잡아내어 문제가 생산에 들어가기 전에 문제를 더 쉽고 빠르게 식별하고 수정할 수 있도록 합니다.
  3. 요구 사항에 대한 명확한 이해: 테스트를 작성하면 개발자가 소프트웨어의 요구 사항과 예상되는 동작을 명확하게 이해하여 오해나 오해를 방지할 수 있습니다.
  4. 쉬운 리팩토링: TDD는 테스트가 의도하지 않은 동작 변경을 포착하는 안전망 역할을 하므로 정기적인 코드 리팩토링을 권장합니다. 이렇게 하면 리팩토링이 쉬워지고 시간이 지남에 따라 코드 품질을 유지하는 데 도움이 됩니다.
  5. 문서화 및 회귀 테스트: TDD의 테스트는 소프트웨어의 예상 동작에 대한 문서화 역할을 하므로 개발자가 코드베이스를 더 쉽게 이해하고 유지 관리할 수 있습니다. 또한 테스트는 회귀 테스트 역할을 하여 변경 사항이 적용된 후에도 기존 기능이 예상대로 계속 작동하는지 확인합니다.
  
  테스트 주도 개발(TDD)의 단점:
  
  1. 초기 시간 및 노력 투자: 코드를 작성하기 전에 테스트를 작성하려면 초기에 시간과 노력을 투자해야 하므로 초기에 개발 프로세스가 느려질 수 있습니다.
  2. 개발자를 위한 학습 곡선: TDD는 개발자에게 학습 곡선이 있을 수 있는 효과적인 테스트 작성 및 테스트 프레임워크 사용과 같은 새로운 기술과 기술을 배우도록 요구할 수 있습니다.
  3. 불완전한 테스트 범위: 가능한 모든 시나리오에 대한 테스트를 작성하는 것은 시간이 많이 걸리고 복잡하여 테스트에 잠재적인 격차가 생길 수 있으므로 완전한 테스트 범위를 달성하는 것은 어려울 수 있습니다.
  4. 유지 관리 오버헤드: 테스트는 소프트웨어가 발전함에 따라 정기적인 유지 관리가 필요할 수 있으며 이로 인해 시간, 노력 및 리소스 측면에서 오버헤드가 추가될 수 있습니다.
  5. 테스트 도구 및 프레임워크에 대한 종속성: TDD는 테스트 도구 및 프레임워크에 크게 의존하며 이러한 도구의 문제 또는 제한 사항은 TDD 접근 방식의 효율성에 영향을 미칠 수 있습니다.
  
  결론적으로 TDD는 향상된 코드 품질, 더 빠른 버그 감지 및 수정, 요구 사항에 대한 명확한 이해, 더 쉬운 리팩토링 및 문서화로 이어질 수 있습니다. 그러나 초기 시간과 노력 투자가 필요하고 개발자를 위한 학습 곡선이 있으며 전체 테스트 범위를 달성하는 데 어려움이 있을 수 있으며 유지 관리 오버헤드가 포함될 수 있습니다. 조직은 소프트웨어 개발 접근 방식의 일부로 TDD를 채택하기로 결정하기 전에 특정 개발 사례, 팀 기술 및 프로젝트 요구 사항을 신중하게 고려해야 합니다.

  ```
* 테스트들 간의 계층에 따라 어떤 단계들이 있을까요?
```
소프트웨어 테스트에는 다양한 수준의 테스트를 나타내는 계층 구조 또는 테스트 피라미드가 있으며 각 수준에는 고유한 범위와 목적이 있습니다. 가장 낮은 수준에서 가장 높은 수준까지 일반적인 테스트 계층 구조에는 다음이 포함됩니다.

1. 단위 테스트: 이는 함수, 메서드 또는 클래스와 같은 개별 코드 단위를 시스템의 나머지 부분과 격리하여 테스트하는 데 중점을 둔 테스트입니다. 단위 테스트는 일반적으로 작은 범위를 가지며 개별 코드 단위가 사양에 따라 올바르게 작동하는지 확인하기 위해 개발자가 작성합니다.
2. 통합 테스트: 시스템 내의 서로 다른 코드 단위 또는 모듈 간의 상호 작용 및 통합을 확인하는 테스트입니다. 통합 테스트는 서로 다른 장치 또는 구성 요소가 전체적으로 함께 작동하는 방식을 테스트하고 올바르게 통합되고 예상 결과를 생성하는지 확인하는 데 중점을 둡니다.
3. 시스템 테스트: 전체 시스템 또는 애플리케이션의 기능과 동작을 확인하는 테스트입니다. 시스템 테스트는 전체 시스템에서 수행되며 일반적으로 품질 보증(QA) 팀 또는 테스터가 수행하여 시스템이 지정된 요구 사항을 충족하고 다양한 시나리오에서 예상대로 작동하는지 확인합니다.
4. 승인 테스트: 시스템 또는 애플리케이션이 최종 사용자 또는 이해 관계자의 요구 사항 및 기대치를 충족하는지 확인하는 테스트입니다. 수락 테스트는 일반적으로 이해 관계자, 클라이언트 또는 최종 사용자가 수행하여 시스템이 원하는 결과를 충족하고 기대 가치를 제공하는지 확인합니다.

테스트의 계층 구조는 피라미드 모양을 따르며 단위 테스트가 기본을 형성하고 가장 많으며 통합 테스트, 시스템 테스트 및 승인 테스트가 맨 위에 있습니다. 이 계층 구조는 더 비용 효율적이고 개발 프로세스 초기에 문제를 파악하는 데 도움이 되는 단위 수준에서 초기 및 빈번한 테스트의 중요성을 강조합니다. 계층 구조를 위로 이동하면 테스트 범위가 증가하지만 실행하는 데 더 많은 비용과 시간이 소요되는 경향이 있으므로 테스트 수는 일반적으로 감소합니다. 서로 다른 수준의 테스트 조합은 소프트웨어가 철저히 테스트되고 원하는 품질 표준을 충족하는지 확인하는 데 도움이 됩니다.
```
  * 유닛 테스트, 통합 테스트, E2E 테스트는 각각 어떤 것을 뜻하나요?
  ```
  단위 테스트, 통합 테스트 및 E2E(End-to-End) 테스트는 소프트웨어 개발 프로세스에서 일반적으로 사용되는 다양한 유형의 소프트웨어 테스트입니다.
  
  단위 테스트: 단위 테스트는 함수, 메서드 또는 클래스와 같은 개별 코드 단위를 나머지 시스템과 분리하여 테스트하는 데 중점을 둔 테스트입니다. 단위 테스트는 일반적으로 개발자가 작성하며 개발 프로세스 중에 실행되어 개별 코드 단위가 사양에 따라 올바르게 작동하는지 확인합니다. 단위 테스트는 개발 프로세스 초기에 문제를 파악하고 각 코드 단위가 예상대로 작동하는지 확인하는 데 도움이 됩니다.
  통합 테스트: 통합 테스트는 시스템 내의 서로 다른 코드 단위 또는 모듈 간의 상호 작용 및 통합을 확인하는 테스트입니다. 통합 테스트는 서로 다른 장치 또는 구성 요소가 전체적으로 함께 작동하는 방식을 테스트하고 올바르게 통합되고 예상 결과를 생성하는지 확인하는 데 중점을 둡니다. 통합 테스트는 일반적으로 통합 시스템이 예상대로 작동하는지 확인하기 위해 단위 테스트 후에 수행됩니다.
  E2E(End-to-End) 테스트: 시스템 테스트 또는 승인 테스트라고도 하는 E2E 테스트는 전체 시스템 또는 애플리케이션의 기능과 동작을 검증하는 테스트입니다. E2E 테스트는 전체 시스템에서 수행되며 실제 사용자 시나리오를 시뮬레이션하여 시스템이 지정된 요구 사항을 충족하고 예상대로 작동하는지 확인합니다. E2E 테스트는 일반적으로 품질 보증(QA) 팀 또는 테스터가 수행하며 시스템이 원하는 결과를 충족하고 최종 사용자에게 예상 가치를 제공하는지 확인합니다.
  
  요약하면 단위 테스트는 개별 코드 단위 테스트에 중점을 두고 통합 테스트는 서로 다른 코드 단위 간의 상호 작용을 확인하며 E2E 테스트는 전체 시스템 또는 애플리케이션의 기능 및 동작을 확인합니다. 이러한 유형의 테스트는 소프트웨어가 철저히 테스트되고 원하는 품질 표준을 충족하는지 확인하기 위해 소프트웨어 개발 프로세스의 여러 단계에서 사용됩니다.
  ```
  * 테스트에 있어서 Stub과 Mock은 어떤 개념을 가리키는 것일까요?
  ```
  소프트웨어 테스팅의 맥락에서 스텁과 모의는 실제 종속성 또는 협력자의 동작을 대체하거나 모방하기 위해 테스트에 사용되는 개체 또는 구성 요소인 테스트 더블과 관련된 개념입니다.
  
  스텁: 스텁은 테스트 중에 메서드 호출에 대해 미리 정의된 응답을 제공하는 테스트 더블입니다. 스텁은 특정 테스트 시나리오에 필요하지 않거나 테스트 목적으로 설정하기 어려운 실제 종속성 또는 협력자를 대체하는 데 사용됩니다. 스텁을 통해 테스터는 테스트 더블의 동작을 제어하고 예상되는 응답을 제공하여 테스트 프로세스를 단순화하고 일관된 결과를 보장할 수 있습니다.
  Mocks: Mocks는 테스트 중인 시스템과 해당 종속성 또는 협력자 간의 상호 작용을 캡처하고 확인하는 테스트 더블입니다. 모의는 실제 종속성 또는 협력자를 대체하고 테스터가 메서드 호출에 대한 기대치를 설정하고 테스트 중에 예상되는 상호 작용이 발생하는지 확인하는 데 사용됩니다. 모의는 테스터가 테스트 중인 시스템이 종속성 또는 협력자와 올바르게 상호 작용하고 예상되는 상호 작용이 발생하는지 확인하는 데 도움이 됩니다.
  
  요약하면 스텁과 목은 실제 종속성 또는 협력자의 동작을 대체하거나 모방하기 위해 소프트웨어 테스트에서 사용되는 테스트 이중 개념입니다. 스텁은 메서드 호출에 대해 미리 정의된 응답을 제공하는 반면 모의는 테스트 중인 시스템과 해당 종속성 또는 협력자 간의 상호 작용을 캡처하고 확인합니다. 이러한 개념은 테스터가 테스트 시나리오에서 종속성 또는 협력자의 동작을 제어하고 확인하여 소프트웨어의 철저하고 안정적인 테스트를 보장하는 데 도움이 됩니다.
  ```
* Jest는 어떤 일을 하며 어떻게 사용하는 테스트 프레임워크일까요?
```
Jest는 응용 프로그램, 특히 React JavaScript 라이브러리로 구축된 응용 프로그램을 테스트하는 데 사용되는 인기 있는 JavaScript 테스트 프레임워크입니다. Jest는 테스트 작성, 실행 및 관리를 위한 포괄적이고 사용하기 쉬운 도구 세트를 제공하므로 JavaScript 개발자를 위한 강력한 테스트 프레임워크가 됩니다.

Jest는 Jest를 테스트 프레임워크로 만드는 몇 가지 주요 기능을 제공합니다.

1. 테스트 러너: Jest에는 테스트를 병렬로 실행할 수 있는 내장 테스트 러너가 포함되어 있어 테스트를 빠르고 효율적으로 실행할 수 있습니다. 테스트 결과의 명확하고 자세한 출력을 제공하여 문제를 쉽게 식별하고 수정할 수 있습니다.
2. 어설션 라이브러리: Jest는 개발자가 테스트에서 예상되는 결과를 정의하기 위해 어설션을 작성할 수 있는 어설션 라이브러리와 함께 제공됩니다. 이렇게 하면 코드 실행의 실제 결과가 예상 결과와 일치하는지 쉽게 확인할 수 있습니다.
3. 모킹 및 스파이: Jest는 기능, 모듈 및 종속성에 대한 모의 및 스파이를 위한 내장 지원을 제공하여 개발자가 스텁 또는 모의와 같은 테스트 더블로 실제 종속성을 대체할 수 있도록 합니다. 이를 통해 테스트 중에 종속성 동작을 쉽게 격리하고 제어할 수 있습니다.
4. 코드 커버리지: Jest는 자동으로 코드 커버리지 보고서를 생성하여 테스트된 코드가 테스트에 의해 커버되는 정도를 보여줍니다. 이를 통해 개발자는 적절하게 테스트되지 않은 코드 영역을 식별하고 전반적인 코드 품질을 개선할 수 있습니다.
5. 스냅샷 테스트: Jest에는 개발자가 렌더링된 UI 구성 요소 또는 데이터 구조의 스냅샷을 캡처하고 비교할 수 있는 스냅샷 테스트가 포함되어 있습니다. 이를 통해 UI 또는 데이터 구조에 대한 의도하지 않은 변경을 쉽게 감지하고 예상 출력이 유지되도록 할 수 있습니다.
6. 구성 및 확장성: Jest는 개발자가 필요에 따라 테스트 환경과 동작을 사용자 정의할 수 있는 유연한 구성 시스템을 제공합니다. 또한 플러그인 및 다른 테스트 도구 및 라이브러리와의 통합을 통한 확장성을 지원합니다.

요약하면 Jest는 테스트 러너, 어설션 라이브러리, 모킹 및 스파이 기능, 코드 커버리지 보고, 스냅샷 테스트, 구성 및 확장성 옵션을 제공하는 포괄적인 JavaScript 테스트 프레임워크입니다. 테스트 작성, 실행 및 관리 프로세스를 단순화하여 JavaScript 애플리케이션 테스트를 위한 강력한 도구로 만듭니다.
```
  * Jest 이외의 테스트 프레임워크는 어떤 것이 있고 어떤 장단점이 있을까요?
  ```
  Jest 외에도 널리 사용되는 JavaScript용 테스트 프레임워크가 여러 개 있습니다. 다음은 장단점과 함께 그 중 일부입니다.
  
  Mocha: Mocha는 유연하고 확장 가능한 테스트 환경을 제공하는 널리 사용되는 테스트 프레임워크입니다. 이를 통해 개발자는 자신의 어설션 라이브러리와 모의 라이브러리를 선택할 수 있으므로 고도로 사용자 정의할 수 있습니다. Mocha는 또한 비동기 테스트를 지원하고 비동기 코드 테스트를 위한 다양한 기능을 제공합니다. 그러나 Mocha는 모킹 및 코드 커버리지와 같은 기능에 대한 추가 설정 및 구성이 필요하며 Jest에 비해 학습 곡선이 더 가파를 수 있습니다.
  Jasmine: Jasmine은 테스트 작성을 위한 BDD 스타일(행동 주도 개발) 구문을 제공하는 인기 있는 또 다른 테스트 프레임워크입니다. 자체 어설션 라이브러리가 포함되어 있으며 모의 및 감시에 대한 기본 제공 지원을 제공합니다. Jasmine은 대규모 커뮤니티를 보유하고 있으며 잘 문서화되어 있어 리소스와 지원을 쉽게 찾을 수 있습니다. 그러나 Jasmine은 BDD 스타일 구문에 익숙하지 않은 개발자의 경우 학습 곡선이 더 가파를 수 있으며 코드 적용 범위와 같은 기능에 대한 추가 구성이 필요할 수 있습니다.
  Enzyme: Enzyme은 React 구성 요소를 테스트하기 위해 특별히 설계된 널리 사용되는 테스트 유틸리티입니다. 구성 요소 동작 시뮬레이션, 구성 요소 렌더링 및 출력 조작을 위한 일련의 테스트 유틸리티를 제공합니다. Enzyme에는 얕은 렌더링 모드와 깊은 렌더링 모드가 있어 개발자가 다양한 방식으로 구성 요소를 테스트할 수 있습니다. Enzyme은 Mocha 및 Jasmine과 같은 다른 테스트 프레임워크와도 잘 통합됩니다. 그러나 Enzyme은 React 구성 요소만 테스트하는 것으로 제한되며 모의 및 코드 적용 범위와 같은 기능에 대한 추가 설정 및 구성이 필요할 수 있습니다.
  AVA: AVA는 성능과 단순성을 강조하는 가볍고 빠른 테스트 프레임워크입니다. 테스트 작성을 위한 간단하고 직관적인 구문을 제공하고 테스트를 동시에 실행하여 빠르고 효율적으로 만듭니다. AVA는 또한 내장된 어설션 라이브러리를 제공하고 즉시 사용 가능한 ES 모듈을 지원합니다. 그러나 AVA는 Jest 또는 Mocha와 같은 다른 테스트 프레임워크에 비해 더 작은 커뮤니티 및 생태계를 가질 수 있으며 내장 모킹 또는 스냅샷 테스트와 같은 모든 고급 기능이 없을 수 있습니다.
  Cypress: Cypress는 웹 애플리케이션을 위한 포괄적이고 강력한 테스트 솔루션을 제공하는 널리 사용되는 엔드 투 엔드 테스트 프레임워크입니다. 이를 통해 개발자는 실제 브라우저에서 실행되는 테스트를 작성할 수 있으며 UI 상호 작용, API 호출 등을 테스트하기 위한 다양한 기능을 제공합니다. 또한 Cypress는 시각적인 테스트 러너와 강력한 디버깅 및 로깅 시스템을 제공합니다. 그러나 Cypress는 종단 간 테스트에 중점을 두고 있으며 단위 또는 통합 테스트에 적합하지 않을 수 있으며 일부 테스트 시나리오에 대한 추가 설정 및 구성이 필요할 수 있습니다.
  
  요약하면 Jest 외에도 JavaScript용 테스트 프레임워크가 몇 가지 더 있으며 각각 고유한 장단점이 있습니다. 테스트 프레임워크의 선택은 프로젝트의 특정 요구 사항, 개발 팀의 전문성 및 친숙성, 수행할 테스트 유형(단위, 통합, 엔드 투 엔드) 및 전체 프로젝트 요구 사항과 같은 요소에 따라 달라집니다. .
  ```
* Puppeteer는 어떤 일을 하며 어떻게 사용하는 테스트 프레임워크일까요?
```
Puppeteer는 헤드리스(즉, 브라우저 UI가 표시되지 않음) Chromium 또는 Chrome 브라우저 인스턴스를 제어하고 자동화하기 위한 고급 API를 제공하는 Node.js 라이브러리입니다. 이를 통해 개발자는 웹 페이지 탐색, 웹 요소와의 상호 작용, 스크린샷 촬영 및 PDF 생성과 같은 다양한 작업을 수행할 수 있습니다.

Puppeteer는 전통적인 테스트 프레임워크가 아니지만 테스트 프레임워크를 구축하기 위한 기반으로 사용하거나 웹 테스트 자동화를 위한 도구로 사용할 수 있습니다. Puppeteer는 실제 브라우저 환경에서 웹 애플리케이션과의 사용자 상호 작용을 시뮬레이션하는 종단 간(E2E) 테스트를 작성하는 데 활용할 수 있는 강력한 API 세트를 제공합니다. Puppeteer는 Jest, Mocha 또는 Jasmine과 같은 널리 사용되는 테스트 프레임워크와 통합되어 다양한 테스트 환경에서 E2E 테스트를 작성하고 실행할 수 있습니다.

사용자 상호 작용 시뮬레이션, 스크린샷 캡처, PDF 생성 기능과 같은 Puppeteer의 주요 기능은 웹 응용 프로그램의 시각적 모양, 동작 및 기능을 테스트하는 데 적합합니다. 헤드리스 브라우저 환경을 제공하여 눈에 보이는 사용자 인터페이스를 표시하지 않고 백그라운드에서 테스트를 실행할 수 있으므로 빌드 시스템 또는 CI/CD(지속적인 통합/지속적인 배포) 파이프라인에서 자동화된 테스트에 적합합니다.

또한 Puppeteer는 쿠키 처리, 네트워크 요청 가로채기, DOM 조작과 같은 기능을 제공하여 개발자가 복잡한 테스트 시나리오 및 유효성 검사를 수행할 수 있도록 합니다. UI 테스트, 회귀 테스트, 성능 테스트 및 브라우저 간 테스트와 같은 다양한 사용 사례에 대한 테스트를 작성하는 데 사용할 수 있습니다.

그러나 Puppeteer는 주로 종단 간 테스트를 위해 설계되었으며 일반적으로 다른 테스트 접근 방식과 도구가 필요한 단위 또는 통합 테스트에 이상적인 선택이 아닐 수 있습니다. 또한 Puppeteer는 Chromium 또는 Chrome 브라우저에만 적용되므로 다른 브라우저와의 호환성이 제한될 수 있습니다. 그럼에도 불구하고 Puppeteer는 웹 테스트 작업을 자동화하는 강력한 도구가 될 수 있으며 더 큰 테스트 프레임워크 또는 도구 집합의 일부로 사용할 수 있습니다.
```

## Quest
* 직전 퀘스트의 메모장의 서버와 클라이언트 각 부분에 유닛 테스트, 통합 테스트, E2E 테스트 등을 추가해 보세요.
  * `npm test` 명령을 통해 모든 테스트가 돌고 그 결과를 출력할 수 있어야 합니다.

## Advanced
* 테스트의 커버리지는 어떤 개념일까요? 프로젝트에서 테스트의 커버리지는 어떻게 접근하는 것이 좋을까요?
