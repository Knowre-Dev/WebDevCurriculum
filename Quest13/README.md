# Quest 13. 웹 API의 응용과 GraphQL

## Introduction
* 이번 퀘스트에서는 차세대 웹 API의 대세로 각광받고 있는 GraphQL에 대해 알아보겠습니다.

## Topics
* GraphQL
  * Schema
  * Resolver
  * DataLoader
* Apollo

## Resources
* [GraphQL](https://graphql.org/)
* [GraphQL.js](http://graphql.org/graphql-js/)
* [DataLoader](https://github.com/facebook/dataloader)
* [Apollo](https://www.apollographql.com/)

## Checklist
* GraphQL API는 무엇인가요? REST의 어떤 단점을 보완해 주나요?
```
GraphQL API는 유연하고 효율적인 방식으로 서버와 상호 작용하고 데이터를 검색하기 위해 GraphQL 쿼리 언어를 사용하는 애플리케이션 프로그래밍 인터페이스(API)입니다. GraphQL은 Facebook에서 개발했으며 유연성, 효율성 및 사용 용이성으로 인해 인기를 얻었습니다.

엔드포인트와 응답의 고정된 구조를 따르는 REST(Representational State Transfer) API와 달리 GraphQL은 클라이언트가 필요한 데이터만 요청하고 응답의 형태를 지정할 수 있도록 합니다. 따라서 GraphQL API는 REST API에 비해 여러 면에서 더 유연하고 효율적입니다.

1. Over-fetching: REST API는 종종 클라이언트가 필요로 하는 것보다 더 많은 데이터를 반환하여 데이터를 과도하게 가져옵니다. 클라이언트는 GraphQL을 사용하여 필요한 정확한 데이터를 지정하여 네트워크를 통해 전송되는 불필요한 데이터의 양을 줄일 수 있습니다.
2. Under-fetching: REST API는 관련 데이터를 가져오기 위해 서로 다른 엔드포인트에 대한 여러 요청을 요구할 수 있으므로 데이터의 under-fetching이 발생할 수 있습니다. GraphQL은 클라이언트가 단일 쿼리에서 모든 관련 데이터를 요청할 수 있도록 하여 요청 수를 줄이고 성능을 향상시킵니다.
3. 버전 관리: REST API는 API의 변경 사항을 처리하기 위해 버전 관리가 필요할 수 있으며, 이로 인해 동일한 엔드포인트의 여러 버전이 생성될 수 있습니다. GraphQL은 클라이언트가 필요한 데이터만 요청할 수 있도록 하여 버전 관리를 피하고 서버는 기존 클라이언트를 손상시키지 않고 필드를 추가하거나 변경할 수 있습니다.
4. 클라이언트 기반 쿼리: GraphQL을 사용하면 클라이언트가 데이터 검색 프로세스를 구동하여 수신하는 데이터에 대해 더 많은 유연성과 제어를 제공할 수 있습니다. 클라이언트는 단일 쿼리에서 필요한 데이터만 요청할 수 있으므로 오버페칭 및 언더페칭 문제가 줄어듭니다.

그러나 GraphQL은 리졸버 기능으로 인해 서버 측에서 복잡성이 증가하고 제대로 구현되지 않을 경우 잠재적인 보안 위험이 있으며 GraphQL에 익숙하지 않은 개발자의 경우 REST에 비해 학습 곡선이 가파르다는 단점도 있습니다. . 또한 GraphQL은 모든 사용 사례에 적합하지 않을 수 있으며 REST는 프로젝트의 요구 사항에 따라 특정 시나리오에서 여전히 실행 가능한 옵션일 수 있습니다.
```
* GraphQL 스키마는 어떤 역할을 하며 어떤 식으로 정의되나요?
```
GraphQL 스키마는 GraphQL API에서 쿼리, 변경 또는 구독할 수 있는 데이터의 구조를 정의합니다. 클라이언트와 서버 간의 계약 역할을 하여 요청할 수 있는 데이터 유형과 지원되는 작업을 지정합니다.

GraphQL 스키마는 API의 유형, 필드 및 관계를 설명하기 위해 사람이 읽을 수 있는 구문인 GraphQL 스키마 정의 언어(SDL)를 사용하여 정의됩니다. GraphQL 스키마의 주요 구성 요소는 다음과 같습니다.

1. 유형: 유형은 GraphQL API에서 쿼리하거나 변경할 수 있는 데이터의 모양을 정의합니다. 개체, 스칼라 값(예: 문자열 또는 숫자), 열거형(미리 정의된 값 집합) 또는 다른 형식으로 구성된 사용자 지정 형식을 나타낼 수 있습니다.
2. 필드: 필드는 유형 내에서 요청하거나 변경할 수 있는 개별 데이터 조각을 정의합니다. 이름과 유형이 있으며 클라이언트가 필터링, 정렬 또는 기타 작업을 위해 값을 전달할 수 있도록 하는 인수도 있을 수 있습니다.
3. 쿼리: 쿼리는 클라이언트가 API에서 수행할 수 있는 읽기 작업을 정의합니다. 요청할 수 있는 데이터 유형과 응답 형태를 지정합니다. 쿼리는 REST의 HTTP GET 요청과 유사하지만 필요한 데이터만 요청할 수 있는 유연성이 있습니다.
4. 돌연변이: 돌연변이는 클라이언트가 API에서 수행할 수 있는 쓰기 작업을 정의합니다. 이를 통해 클라이언트는 GraphQL API에서 데이터를 수정하거나 생성할 수 있습니다. 변형은 REST의 HTTP POST, PUT, DELETE 또는 PATCH 요청과 유사합니다.
5. 구독: 구독은 클라이언트가 구독하고 데이터가 변경될 때 업데이트를 받을 수 있는 실시간 데이터 스트림을 정의합니다. 구독을 통해 클라이언트는 변경 사항에 대해 지속적으로 서버를 폴링하지 않고도 실시간 업데이트를 받을 수 있습니다.

GraphQL 스키마는 일반적으로 GraphQL 스키마 언어를 사용하여 서버 측에서 정의되며 API에서 사용 가능한 데이터 및 작업을 정의하는 계약 역할을 합니다. 그런 다음 클라이언트는 이 스키마를 사용하여 API와 상호 작용하고 유연하고 효율적인 방식으로 데이터를 요청하거나 수정할 수 있습니다.
```
* GraphQL 리졸버는 어떤 역할을 하며 어떤 식으로 정의되나요?
```
GraphQL 해석기는 GraphQL API의 필드 값을 해석하는 기능입니다. 클라이언트가 쿼리 또는 변형 요청을 할 때 특정 필드에 대한 데이터를 검색하거나 계산하는 방법을 결정하는 데 사용됩니다. 리졸버는 GraphQL API의 서버측 구현에서 필수적인 부분입니다.

리졸버는 서버 측의 함수로 정의되며 GraphQL 스키마의 특정 필드와 연결됩니다. 클라이언트가 쿼리 또는 변형 요청을 하면 GraphQL 런타임은 적절한 해석기를 실행하여 요청된 필드의 값을 검색하거나 계산합니다.

리졸버는 일반적으로 JavaScript, Python, Ruby 또는 기타 언어와 같이 GraphQL 서버에서 지원하는 프로그래밍 언어를 사용하여 정의됩니다. 정확한 구문 및 구현 세부 정보는 사용 중인 GraphQL 서버 라이브러리 또는 프레임워크에 따라 다를 수 있습니다.

확인자는 데이터베이스에서 데이터 가져오기, 외부 API 호출, 계산 수행 또는 하드코딩된 값 반환과 같은 다양한 작업을 수행할 수 있습니다. Resolver는 네트워크 요청 또는 데이터베이스 쿼리와 같은 I/O 관련 작업을 처리하기 위해 비동기식일 수도 있습니다.

리졸버는 부모 개체(확인할 필드를 포함하는 개체), 쿼리 또는 변형에 전달된 인수, 컨텍스트(모두가 액세스할 수 있는 데이터를 저장하는 데 사용할 수 있는 공유 개체)를 포함하여 몇 가지 중요한 정보에 액세스할 수 있습니다. 확인자, 사용자의 인증 및 권한 부여 정보.

확인자는 추상 GraphQL 쿼리 및 변형을 서버에서 구체적인 데이터 검색 또는 수정 작업으로 변환하는 데 중요한 역할을 합니다. GraphQL API의 필드 값을 검색하거나 계산하기 위한 로직을 제공하며 GraphQL API를 구축하고 구현하는 데 있어 기본이 되는 부분입니다.
```
  * GraphQL 리졸버의 성능 향상을 위한 DataLoader는 무엇이고 어떻게 쓰나요?
  ```
  DataLoader는 데이터 검색 작업을 일괄 처리 및 캐싱하여 GraphQL 리졸버의 성능을 개선하는 데 도움이 되는 GraphQL 에코시스템의 인기 있는 유틸리티 라이브러리입니다. 데이터베이스, API 또는 기타 원격 서비스와 같은 외부 데이터 소스에서 데이터를 효율적으로 가져오기 위해 GraphQL 서버에서 일반적으로 사용됩니다.
  
  DataLoader의 주요 목적은 GraphQL 쿼리로 인해 여러 개별 데이터 검색 작업이 발생하여 중복되고 비효율적인 데이터베이스 또는 API 쿼리가 발생할 때 발생하는 "N+1" 문제를 해결하는 것입니다. DataLoader는 여러 데이터 검색 작업을 단일 요청으로 일괄 처리하여 왕복 횟수를 줄이고 전반적인 성능을 개선하여 이 문제를 해결합니다.
  DataLoader는 확인자가 만든 데이터 검색 요청을 가로채서 배치로 수집하는 방식으로 작동합니다. 그런 다음 외부 데이터 소스에 대한 단일 요청에서 이러한 배치를 결합하고 실행하여 요청 수를 효과적으로 줄이고 데이터 검색을 최적화합니다. DataLoader는 또한 캐싱 기능을 제공하여 이전에 가져온 데이터를 재사용할 수 있도록 하고 중복 데이터 가져오기를 방지하여 성능을 더욱 향상시킵니다.
  GraphQL 해석기에서 DataLoader를 사용하려면 일반적으로 다음 단계가 필요합니다.

  1. DataLoader 가져오기 및 초기화: DataLoader는 일반적으로 별도의 라이브러리로 설치되며 리졸버 코드로 가져와야 합니다. 그런 다음 주어진 키 세트에 대한 데이터를 가져오는 방법을 지정하는 데이터 검색 기능으로 초기화됩니다.
  2. 리졸버 함수에서 DataLoader 사용: 리졸버 함수 내에서 DataLoader를 사용하여 데이터 검색 작업을 일괄 처리하고 캐시할 수 있습니다. 데이터 원본에서 데이터를 직접 가져오는 대신 리졸버는 요청을 수집하고 일괄 처리할 원하는 키를 사용하여 DataLoader 인스턴스를 호출할 수 있습니다. 확인자는 요청된 데이터로 확인되는 Promise를 반환할 수 있습니다.
  3. DataLoader에서 데이터 검색: DataLoader는 요청된 데이터로 확인되는 Promise를 반환합니다. 해석기는 해당 필드에 대해 해석된 값으로 이 데이터를 GraphQL 클라이언트에 반환할 수 있습니다.
  GraphQL 리졸버에서 DataLoader를 사용하면 중복되고 비효율적인 데이터 검색 작업을 최소화할 수 있으므로 성능이 향상되고 외부 데이터 소스에 대한 부하가 감소합니다. DataLoader는 GraphQL API에서 데이터 검색을 최적화하기 위한 강력한 도구이며 많은 GraphQL 서버 구현에서 널리 사용됩니다.
  ```
* 클라이언트 상에서 GraphQL 요청을 보내려면 어떻게 해야 할까요?
```
클라이언트에서 GraphQL 요청을 보내려면 일반적으로 다음 단계를 따라야 합니다.

1. HTTP 라이브러리 선택: 클라이언트 측 애플리케이션에서 HTTP 요청을 할 수 있는 HTTP 라이브러리 또는 클라이언트를 선택해야 합니다. 인기 있는 옵션으로는 Axios, Fetch 또는 Apollo Client 또는 Relay와 같은 GraphQL 전용 클라이언트가 있습니다.
2. GraphQL 쿼리 구성: 서버로 보내려는 GraphQL 쿼리 또는 변형을 작성합니다. 여기에는 작업 유형(쿼리, 변형 또는 구독), 요청하려는 필드 및 전달해야 하는 인수 또는 변수를 지정하는 작업이 포함됩니다.
3. 요청 형식 지정: GraphQL 요청은 일반적으로 서버의 GraphQL 엔드포인트에 대한 POST 요청으로 전송됩니다. GraphQL 쿼리 또는 변형을 요청 본문으로 사용하여 요청 형식을 POST 요청으로 지정해야 합니다. 값이 "application/json"인 "Content-Type" 헤더와 같은 적절한 헤더를 설정해야 할 수도 있습니다.
4. 요청 보내기: 선택한 HTTP 라이브러리 또는 클라이언트를 사용하여 GraphQL 요청을 서버로 보냅니다. 여기에는 일반적으로 GraphQL 서버에 대한 끝점 URL, 형식화된 요청 본문 및 필요할 수 있는 모든 헤더 또는 인증 정보를 제공하는 것이 포함됩니다.
5. 응답 처리: 요청이 전송되면 서버는 요청된 데이터 또는 오류 응답으로 응답합니다. 일반적으로 JSON 응답을 구문 분석하고 관련 데이터 또는 오류 정보를 추출하여 클라이언트 측 코드에서 응답을 처리해야 합니다.
6. UI 업데이트: 응답을 받은 후 검색된 데이터로 클라이언트 측 UI 또는 애플리케이션 상태를 업데이트하거나 발생한 오류를 처리할 수 있습니다. 여기에는 구성 요소 업데이트, 사용자에게 데이터 표시 또는 검색된 데이터를 기반으로 추가 작업 트리거가 포함될 수 있습니다.

정확한 구현 세부 정보 및 구문은 사용 중인 HTTP 라이브러리 또는 클라이언트와 클라이언트 측 애플리케이션의 프로그래밍 언어 또는 프레임워크에 따라 다를 수 있습니다. 클라이언트에서 GraphQL 요청을 올바르게 사용하려면 선택한 라이브러리 또는 클라이언트에서 제공하는 문서 및 예제를 참조하는 것이 중요합니다.
```
  * Apollo 프레임워크(서버/클라이언트)의 장점은 무엇일까요?
  ```
  Apollo 서버(GraphQL 서버 구축용)와 Apollo 클라이언트(클라이언트 측에서 GraphQL API 사용용)를 모두 포함하는 Apollo 프레임워크는 개발자에게 다음과 같은 몇 가지 이점을 제공합니다.
  
  1. 포괄적인 도구: Apollo는 GraphQL 애플리케이션을 개발하고 디버깅하기 위한 다양한 도구 세트를 제공합니다. 여기에는 GraphQL 내부 검사, 대화형 쿼리 테스트를 위한 GraphQL Playground, 클라이언트 측 캐싱, 오류 처리 및 성능 모니터링에 대한 기본 제공 지원과 같은 기능이 포함됩니다.
  2. 유연하고 확장 가능: Apollo를 사용하면 개발자가 유연하고 확장 가능한 방식으로 GraphQL API 및 클라이언트를 구축할 수 있습니다. 맞춤형 리졸버, 미들웨어 및 플러그인을 지원하여 GraphQL API 및 클라이언트의 동작을 세밀하게 제어할 수 있습니다.
  3. 확장성: Apollo는 확장 가능하도록 설계되어 다양한 크기와 복잡성의 애플리케이션 구축에 적합합니다. Apollo 서버는 성능을 최적화하기 위해 일괄 처리 및 캐싱과 같은 기능을 지원하고, Apollo 클라이언트는 고급 캐싱 및 상태 관리 옵션을 제공하여 클라이언트 측 성능을 향상시킵니다.
  4. 강력한 커뮤니티 및 생태계: Apollo에는 대규모의 활발한 개발자 커뮤니티가 있습니다. 즉, 풍부한 리소스, 문서, 자습서 및 커뮤니티 기반 확장에 대한 액세스를 의미합니다. 또한 React, Angular 및 Vue와 같은 인기 있는 웹 프레임워크 및 라이브러리와 잘 통합되어 GraphQL을 기존 프로젝트에 쉽게 통합할 수 있습니다.
  5. 교차 플랫폼 호환성: Apollo는 JavaScript, TypeScript 및 Kotlin과 같은 다양한 프로그래밍 언어와 함께 사용할 수 있는 교차 플랫폼 프레임워크로, 개발자가 다양한 서버 및 클라이언트 플랫폼에서 GraphQL 애플리케이션을 구축할 수 있도록 합니다.
  6. GraphQL 우선 접근 방식: Apollo는 "GraphQL 우선" 접근 방식을 취합니다. 즉, GraphQL 작업에 특별히 최적화된 전용 도구와 기능을 제공합니다. 여기에는 개발 프로세스를 간소화하고 개발자 생산성을 향상시키는 자동 스키마 생성, 유형 검사 및 코드 생성과 같은 기능이 포함됩니다.
  7. 클라이언트측 캐싱 및 상태 관리: Apollo 클라이언트는 고급 클라이언트측 캐싱 및 상태 관리 기능을 제공하여 개발자가 데이터 가져오기를 최적화하고 불필요한 네트워크 요청을 최소화할 수 있도록 합니다. 이를 통해 클라이언트 측 애플리케이션의 성능과 응답성을 크게 향상시킬 수 있습니다.
  
  전반적으로 Apollo 프레임워크는 포괄적인 도구, 확장성, 플랫폼 간 호환성 및 강력한 커뮤니티 에코시스템을 통해 GraphQL API 및 클라이언트를 구축하기 위한 강력하고 유연한 도구 세트를 제공하므로 최신 GraphQL 애플리케이션을 구축하기 위해 개발자들 사이에서 인기 있는 선택입니다.
  ```
  * Apollo Client를 쓰지 않고 Vanilla JavaScript로 GraphQL 요청을 보내려면 어떻게 해야 할까요?
  ```
  Apollo 클라이언트를 사용하지 않고 바닐라 JavaScript에서 GraphQL 요청을 하려면 내장 fetch() 함수 또는 다른 HTTP 클라이언트 라이브러리를 사용하여 적절한 헤더 및 페이로드와 함께 POST 요청을 GraphQL 끝점으로 보낼 수 있습니다.
  ```
* GraphQL 기반의 API를 만들 때 에러처리와 HTTP 상태코드 등은 어떻게 하는게 좋을까요?
```
GraphQL 기반 API를 생성할 때 오류 처리 및 HTTP 상태 코드는 일관되고 신중한 방식으로 접근해야 합니다. 다음은 몇 가지 일반적인 모범 사례입니다.

1. GraphQL 오류 사용: GraphQL에는 응답 페이로드에 포함된 "오류"라는 자체 오류 처리 메커니즘이 내장되어 있습니다. GraphQL 쿼리 또는 변형을 실행하는 동안 오류가 발생하면 응답 페이로드의 'errors' 필드에 오류 개체를 포함할 수 있습니다. 오류 메시지, 오류 코드 및 필드 경로와 같은 오류에 대한 세부 정보를 제공합니다. 오류가 발생했습니다. 이를 통해 클라이언트는 구조화된 오류 정보를 수신하고 통합된 방식으로 오류를 처리할 수 있습니다.
2. 적절한 HTTP 상태 코드 사용: GraphQL은 자체 오류 처리 메커니즘을 사용하지만 적절한 HTTP 상태 코드를 사용하여 요청의 전체 상태를 나타내는 것도 중요합니다. 성공적인 GraphQL 작업의 경우 HTTP 200 OK 상태 코드를 사용할 수 있으며, 오류의 경우 오류의 특성에 따라 400 Bad Request, 401 Unauthorized, 403 Forbidden 또는 500 Internal Server Error와 같은 다른 적절한 HTTP 상태 코드를 사용할 수 있습니다. 오류. 이를 통해 클라이언트는 GraphQL 오류 외에도 HTTP 상태 코드를 기반으로 요청의 전체 결과를 해석할 수 있습니다.
3. 오류 메시지에 일관성 있고 구체적: GraphQL 오류 또는 HTTP 응답에 오류 메시지를 포함할 때 오류 메시지의 형식과 구조가 일관되어야 합니다. 클라이언트가 오류의 특성을 이해하고 적절한 조치를 취할 수 있도록 충분한 정보를 제공하는 명확하고 의미 있는 오류 메시지를 사용하십시오. 잠재적인 보안 위험을 방지하기 위해 오류 메시지에 민감한 정보를 노출하지 마십시오.
4. 필드 수준 오류 고려: GraphQL은 필드 수준 오류를 허용합니다. 즉, 작업 수준이 아닌 개별 필드 수준에서 오류를 지정할 수 있습니다. 이를 통해 보다 세분화된 오류 정보를 제공하고 클라이언트가 특정 필드 수준에서 오류를 식별하고 처리하는 데 도움을 줄 수 있습니다. 그러나 필드 수준 오류에 민감한 정보를 노출하지 않도록 주의하십시오.
5. 테스트 오류 시나리오: 잘못된 쿼리 또는 변형, 인증 실패, 권한 부여 실패 및 기타 잠재적 오류 시나리오를 포함한 다양한 오류 시나리오로 GraphQL API를 철저하게 테스트합니다. 오류 메시지의 형식, HTTP 상태 코드 및 API의 전반적인 동작을 포함하여 API가 이러한 시나리오에 어떻게 응답하는지 테스트하십시오.

이러한 모범 사례를 따르면 강력한 오류 처리 및 적절한 HTTP 상태 코드를 사용하여 GraphQL 기반 API를 생성할 수 있습니다. 이를 통해 클라이언트는 효과적으로 오류를 처리하고 요청의 전체 상태를 해석할 수 있습니다.
```

## Quest
* 메모장의 서버와 클라이언트 부분을 GraphQL API로 수정해 보세요.

## Advanced
* GraphQL이 아직 제대로 수행하지 못하거나 불가능한 요구사항에는 어떤 것이 있을까요?
* GraphQL의 경쟁자에는 어떤 것이 있을까요?
