# Quest 00. 형상관리 시스템

## Introduction
* git은 2021년 현재 개발 생태계에서 가장 각광받고 있는 버전 관리 시스템입니다. 이번 퀘스트를 통해 git의 기초적인 사용법을 알아볼 예정입니다.

## Topics
* git
  * `git clone`, `git add`, `git commit`, `git push`, `git pull`, `git branch`, `git stash` 명령
  * `.git` 폴더
* GitHub

## Resources
* [Resources to learn Git](https://try.github.io)
* [Learn Git Branching](https://learngitbranching.js.org/?locale=ko)
* [Inside Git: .Git directory](https://githowto.com/git_internals_git_directory)

## Checklist
* 형상관리 시스템은 왜 나오게 되었을까요?
* - <aside>
💡 소프트웨어의 변경사항을 체계적으로 추적하고 통제하는 것.

형상 관리는 일반적인 단순 버전관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간.

소프트웨어 개발에서는 단순 파일 변경내역을 관리할 뿐만 아니라 소프트웨어 개발에서 발생할 수 있는 다양한 결과물(요구사항 정의서, 설계 문서, 코드 등등)에 대해 형상을 만들고 이를 체계적으로 관리하고자 나오게되었다.

</aside>

* git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?

- 특징 : 2005년 개발된 형상관리 도구로 매우 빠른 속도를 가지고 있으며 분산형 관리 시스템을 가지고 있다. 다른 형상관리 도구에 비해 다양한 기능을 지원하며 최근 가장 대중화되어 사용되고 있다. 처음 사용시 다른 도구에 비해 사용법을 숙지하는데 어려움을 가질 수 있으나 로컬 관리와 중앙 관리가 모두 가능하여 장소에 구애받지 않고 협업을 가능케 한다.                                                                                                                              

* 분산형 형상관리 시스템이란,
 - 분산버전관리 시스템에서 저장소는 모든 클라이언트가 저장소가 될 수 있다. 예를 들어 TFS에서 get latest version을 통해 저장소에서 프로젝트를 가져오면, 저장소에서 사용자의 컴퓨터에 최신의 코드를 받아오게 된다. 이 말은 소스 코드는 물론 그동안의 변경 이력까지 모든 정보를 가져와 로컬 컴퓨터 또한 완전한 저장소가 된다



  * git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?
  - * git을 분산형 시스템으로 채택한 이유
 - 하나의 서버에 집중되어 모든 작업 내역이 저장되는 중앙 집중형 형상관리 체계와 달리 개개인의 작업 히스토리 역시 각자의 서버에 저장해 관리될 수 있어 같은 파일 하나를 여러명이 동시에 작업하는 병렬 개발이 가능하며 'commit'이라는 행위 자체가 공동 코드로 즉시 병합됨을 의미하지 않아 개인 작업/공동 작업으로 분리될 수 있다. 따라서, 예기치 못 한 충돌이나 변경 사항을 해결하기 위한 시간을 최소화 시켜준다
 - 
* git과 GitHub은 어떻게 다를까요?
 - git은 형상관리 도구이며,  github는 git을 공유/업로드 할 수 잇는 눈에 보이는 웹 호스팅 서비스, 즉 플랫폼이다.
 
* git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?
 - git clone : 원격 저장소에 있는 작업/프로젝트를 로컬 저장소로 가지고 오는(복제) 명령어
- git add : 작업 중인 로컬 저장소에 있는 파일들을 스테이징 상태로 변경시켜주는(커밋 가능한 상태) 명령어
- git commit : 로컬 저장소(디렉토리)에 있는 모든 파일에 대한 스냅샷(이전 스냅샷과 비교하여 변경된 부분)을 기록하는 명령어
- git push : 로컬 저장소에서 작업한 후 commit한 내역을 원격 저장소로 보내는 명령어
- git pull : push와 반대로 원격 저장소에 업로드된 작업 내역을 로컬 저장소로 가져오고 싶을 때 사용하는 명령어
- git branch : 여러 명이 각기 다른 저장소에서 작업하고 싶을 때 작업 공간(branch)를 만들어주는 명령어로 모든 브랜치의 목록을 보거나, 생성하고 삭제할 수 있음
- git stash : 지금 바로 commit 하고 싶지는 않지만 다른 작업을 해야 할 때 저장해놓고 나중에 가져와서 쓰려고 할 때 사용하는 저장소이자 명령어

* git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?
  - **Object 파일 개념 정리**

깃은 Git.디렉토리 안에 objects 디렉토리에 파일과 관련해 총 세가지 유형을 가지게 된다.

1. blob : 실제 데이터를 저장

2. tree : commit한 시점의 버전의 파일들의 주소를 저장

3. commit : tree의 주소와 이전 버전의 주소를 저장

이는 위로 갈수록 세부적인 실제 데이터를 가지게 된다.

working directory (working copy, working tree)

기본적으로 우리가 볼 수 있는 디렉토리 우리가 지금 현재 파일을 다루는 디렉토리를 말한다.

---

- Head : 모든 브렌치에는 HEAD값이 존재하는데, HEAD는 브렌치의 마지막 커밋 즉 현재 속한 브랜치의 가장 최신 커밋을 의미합니다.

## **예시**

### checkout으로 앞뒤 이동

⭐️ **^ 또는 ~: 갯수만큼 해당 브렌치의 이전(옛날)으로 이동**

```
git checkout HEAD^
```

```
git checkout HEAD^^^
```

## **⭐️ -: 해당 브랜치의 한 단계 최근 커밋으로 이동**

```
git checkout -
```

---

- Commit : commit 객체는 tree 객체에 대한 참조, 부모(이전 커밋) 객체와 작성자와 같은 메타 데이터에 대한 참조를 저장한다.
- Branch : 효과적으로 파일의 변경사항에 대한 스냅샷을 보여주는 포인터의 일종이다. 새로운 기능을 추가하거나 버그/이슈를 수정할 때 브랜치를 생성/사용하여 효율적으로 작업을 할 수 있다.
- Tag : 특정 commit에 별명을 붙여주는 명령어로 Tag를 통해서 commit 상태로 쉽게 변경하거나 reset을 통해 돌아가는 것 역시 쉽다. release 버전을 명시해 특정 태그에 해당하는 버전을 배포할 수도 있다.


* 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?
 - git log에서 해당 파일 업로드된 commit id 확인하고, git reset --hard 되돌리고자 하는 commit id 를 입력 하여 되돌린다.

## Quest
* GitHub에 가입한 뒤, [이 커리큘럼의 GitHub 저장소](https://github.com/KnowRe-Dev/WebDevCurriculum)의 우상단의 Fork 버튼을 눌러 자신의 저장소에 복사해 둡니다.
* Windows의 경우 같이 설치된 git shell을, MacOSX의 경우 터미널을 실행시켜 커맨드라인에 들어간 뒤, 명령어를 이용하여 복사한 저장소를 clone합니다.
  * 앞으로의 git 작업은 되도록 커맨드라인을 통해 하는 것을 권장합니다.
* 이 문서가 있는 폴더 바로 밑에 있는 sandbox 폴더에 파일을 추가한 후 커밋해 보기도 하고, 파일을 삭제해 보기도 하고, 수정해 보기도 하면서 각각의 단계에서 커밋했을 때 어떤 것들이 저장되는지를 확인합니다.
* `clone`/`add`/`commit`/`push`/`pull`/`branch`/`stash` 명령을 충분히 익혔다고 생각되면, 자신의 저장소에 이력을 push합니다.

## Advanced
* Mercurial은 어떤 형상관리 시스템일까요? 어떤 장점이 있을까요?
* 실리콘밸리의 테크 대기업들은 어떤 형상관리 시스템을 쓰고 있을까요?
