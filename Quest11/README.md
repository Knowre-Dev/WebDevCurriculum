# Quest 11. RDB의 기초와 ORM

## Introduction
* 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics
* RDBMS
* MySQL
* ORM
* Hash
  * scrypt

## Resources
* [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
* [Sequelize](https://sequelize.org/)
* [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist
* RDBMS 테이블의 정규화는 무엇인가요?
```
관계형 데이터베이스 관리 시스템(RDBMS) 맥락에서 정규화는 중복을 최소화하고 데이터 무결성을 보장하는 방식으로 데이터베이스 테이블을 구성하고 구조화하는 프로세스를 의미합니다. 정규화의 목표는 데이터 중복을 제거하고 불일치를 방지하며 테이블 간의 관계를 설정하여 체계적이고 효율적인 관계형 데이터베이스를 만드는 것입니다.

정규화에는 일반적으로 큰 테이블을 각각 고유한 목적을 가진 더 작고 더 특수화된 테이블로 나눈 다음 기본 키 및 외래 키와 같은 키를 사용하여 이러한 테이블 간의 관계를 설정하는 작업이 포함됩니다. 중복을 최소화하고 데이터 무결성을 향상시키기 위해 테이블을 구조화하기 위한 지침을 제공하는 일반적으로 정규 형식(NF)이라고 하는 몇 가지 정규화 형식 또는 수준이 있습니다.

RDBMS에서 정규화의 이점 중 일부는 다음과 같습니다.

1. 데이터 중복 제거: 정규화는 데이터 중복을 제거하고 각 데이터 조각이 데이터베이스의 한 위치에만 저장되도록 합니다. 이것은 필요한 저장 공간을 줄이고 데이터의 불일치 또는 모순의 위험을 최소화합니다.
2. 향상된 데이터 무결성: 정규화는 데이터가 일관되고 조직적인 방식으로 저장되도록 하여 데이터 무결성 제약 조건을 적용하는 데 도움이 됩니다. 이렇게 하면 삽입, 업데이트 및 삭제 이상과 같은 데이터 이상을 방지하여 데이터가 일관되지 않거나 잘못될 수 있습니다.
3. 간소화된 데이터베이스 유지 관리: 정규화를 통해 데이터베이스 구조를 보다 모듈화하고 유지 관리하기가 더 쉬워집니다. 데이터 모델에 대한 변경 또는 업데이트는 데이터베이스의 다른 부분에 영향을 주지 않고 지역화된 방식으로 이루어질 수 있습니다. 따라서 요구 사항이 변화함에 따라 데이터베이스 구조를 보다 쉽게 ​​관리하고 수정할 수 있습니다.
4. 향상된 쿼리 성능: 정규화는 처리해야 하는 데이터의 양을 줄이고 복잡한 조인 또는 중복 데이터 검색의 필요성을 제거하여 쿼리 성능을 향상시킬 수 있습니다. 이는 특히 데이터 무결성 수준이 높은 대규모 데이터베이스에서 보다 효율적이고 빠른 데이터베이스 쿼리를 생성할 수 있습니다.

전반적으로 정규화는 RDBMS 설계에서 관계형 데이터베이스의 무결성, 효율성 및 유지 관리 가능성을 보장하는 데 도움이 되는 중요한 개념입니다. 1NF(1차 정규형), 2NF(2차 정규형), 3NF(3차 정규형) 및 상위 형식과 같은 다양한 정규화 형식은 특정 요구 사항을 충족하고 데이터 중복을 최소화하도록 데이터베이스 테이블을 구성하기 위한 지침을 제공합니다.
```
* MySQL 외의 RDB에는 어떤 것들이 있나요?
```
관계형 데이터베이스 관리 시스템(RDBMS)은 사용자가 관계형 데이터베이스를 생성, 관리 및 조작할 수 있도록 하는 소프트웨어 응용 프로그램입니다. 널리 사용되는 오픈 소스 RDBMS인 MySQL 외에도 시장에서 사용할 수 있는 몇 가지 잘 알려진 RDBMS 옵션이 있습니다. 이들 중 일부는 다음과 같습니다.

Microsoft SQL Server: Microsoft에서 개발한 SQL Server는 견고성, 확장성 및 다른 Microsoft 제품과의 통합으로 잘 알려진 널리 사용되는 RDBMS입니다. 복잡한 쿼리 지원, 비즈니스 인텔리전스 도구 및 데이터 웨어하우징 기능과 같은 고급 기능을 제공합니다.
Oracle Database: Oracle Corporation에서 개발한 Oracle Database는 가장 강력하고 기능이 풍부한 RDBMS 옵션 중 하나입니다. 고성능, 확장성 및 보안 기능으로 유명합니다. 미션 크리티컬 애플리케이션 및 데이터를 처리하기 위해 대기업에서 널리 사용됩니다.
PostgreSQL: "Postgres"라고도 하는 PostgreSQL은 확장성, 안정성 및 SQL 표준 준수로 잘 알려진 널리 사용되는 오픈 소스 RDBMS입니다. 공간 데이터, 전체 텍스트 검색 및 JSON 데이터 유형 지원과 같은 고급 기능을 제공합니다.
IBM Db2: IBM에서 개발한 Db2는 확장성, 보안 및 IBM의 다른 소프트웨어 제품과의 통합과 같은 엔터프라이즈급 기능으로 잘 알려진 RDBMS를 포함한 데이터 관리 제품군입니다. 복잡한 워크로드 및 데이터 집약적인 애플리케이션을 처리하기 위해 대기업에서 널리 사용됩니다.
SQLite: SQLite는 모바일 장치, 웹 브라우저 및 내장형 시스템을 비롯한 많은 응용 프로그램에 내장된 경량 파일 기반 RDBMS입니다. 단순성, 효율성 및 자체 포함 특성으로 유명하여 모바일 앱 및 기타 소규모 애플리케이션의 로컬 스토리지로 널리 사용됩니다.

이것은 MySQL 외에 다른 RDBMS 옵션의 몇 가지 예일 뿐입니다. 시장에는 각각 고유한 기능, 강점 및 사용 사례가 있는 다른 많은 RDBMS 옵션이 있습니다. RDBMS의 선택은 응용 프로그램의 특정 요구 사항, 확장성 요구 사항, 예산 및 개발 팀의 기술 집합과 같은 다양한 요소에 따라 달라집니다.
```
  * Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?
  ```
  관계형 데이터베이스 외에도 최신 소프트웨어 응용 프로그램에 사용되는 몇 가지 다른 유형의 데이터베이스가 있습니다. 이들 중 일부는 다음과 같습니다.
  
  1. NoSQL 데이터베이스: NoSQL("not only SQL"을 의미함) 데이터베이스는 기존의 관계형 데이터베이스 모델을 따르지 않는 데이터베이스 클래스입니다. 소셜 미디어 데이터, 센서 데이터 및 멀티미디어 콘텐츠와 같은 대량의 비정형 또는 반정형 데이터를 처리하도록 설계되었습니다. NoSQL 데이터베이스의 예로는 MongoDB(문서 기반 데이터베이스), Cassandra(열 형식 데이터베이스) 및 Redis(키-값 저장소)가 있습니다.
  2. 그래프 데이터베이스: 그래프 데이터베이스는 그래프로 구성된 상호 연결된 노드 또는 정점의 형태로 데이터를 저장하고 관리하도록 설계되었습니다. 소셜 네트워크, 추천 엔진 및 사기 탐지와 같이 데이터 요소 간의 관계가 중요한 사용 사례에 특히 적합합니다. 그래프 데이터베이스의 예로는 Neo4j, Amazon Neptune 및 OrientDB가 있습니다.
  3. 시계열 데이터베이스: 시계열 데이터베이스는 센서 데이터, 로그 파일 및 금융 데이터와 같은 대량의 타임스탬프 데이터를 처리하는 데 최적화되어 있습니다. 시간이 지남에 따라 변경되는 데이터를 효율적으로 저장, 관리 및 분석하도록 설계되었습니다. 시계열 데이터베이스의 예로는 InfluxDB, TimescaleDB 및 OpenTSDB가 있습니다.
  4. 열형 데이터베이스: 열형 데이터베이스는 행이 아닌 열에 데이터를 저장하므로 빠른 쿼리 및 집계가 필요한 분석 워크로드에 적합합니다. 일반적으로 데이터 웨어하우징, 비즈니스 인텔리전스 및 분석 애플리케이션에 사용됩니다. 열 형식 데이터베이스의 예로는 Google Bigtable, Apache HBase 및 ClickHouse가 있습니다.
  5. 객체 지향 데이터베이스: 객체 지향 데이터베이스는 복잡한 객체와 그 관계를 저장하고 관리하도록 설계되어 객체 지향 프로그래밍 언어와 객체 지향 데이터 모델을 다루는 애플리케이션에 적합합니다. 객체 지향 데이터베이스의 예로는 db4o, ObjectDB 및 Versant가 있습니다.
  
  이는 관계형 데이터베이스 외에 다른 유형의 데이터베이스에 대한 몇 가지 예일 뿐입니다. 각 유형의 데이터베이스에는 고유한 강점과 사용 사례가 있으며 데이터베이스 선택은 응용 프로그램의 특정 요구 사항, 데이터 모델, 성능 요구 사항 및 확장성 고려 사항에 따라 다릅니다.
  ```
* RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?
```
RDBMS(관계형 데이터베이스 관리 시스템)의 인덱싱은 테이블에서 데이터 검색 및 쿼리를 최적화하는 데 사용되는 기술입니다. 여기에는 하나 이상의 열에 있는 값을 기반으로 테이블에서 행을 찾고 검색하는 더 빠르고 효율적인 방법을 제공하는 인덱스라고 하는 추가 데이터 구조를 만드는 작업이 포함됩니다.


색인은 책 전체를 읽지 않고도 특정 주제를 빠르게 찾을 수 있는 책의 색인 섹션과 비슷합니다. 마찬가지로 데이터베이스 인덱스를 사용하면 RDBMS가 전체 테이블을 스캔하지 않고도 테이블에서 행을 빠르게 찾고 검색할 수 있습니다.

인덱스는 테이블의 하나 이상의 열에 생성할 수 있으며 실제 테이블 데이터와 별도로 저장됩니다. 인덱스가 있는 열과 관련된 쿼리가 실행될 때 RDBMS는 인덱스를 사용하여 전체 테이블을 스캔하는 대신 쿼리 기준과 일치하는 행을 빠르게 찾을 수 있습니다. 이는 특히 수백만 또는 수십억 개의 행이 있는 대형 테이블의 경우 쿼리 성능을 크게 향상시킬 수 있습니다.

다음을 포함하여 RDBMS에서 사용할 수 있는 다양한 유형의 인덱스가 있습니다.

1. B-Tree 인덱스: RDBMS에서 가장 많이 사용되는 인덱스 유형입니다. 부울 또는 열거형 열과 같이 고유 값 수가 적은 열에 적합합니다.
2. 해시 인덱스: 이 유형의 인덱스는 고유 값의 수가 많은 카디널리티가 높은 열에 사용됩니다. 해시 인덱스는 일반적으로 범위 쿼리 또는 패턴 일치에 대한 B-Tree 인덱스만큼 효율적이지 않습니다.
3. 비트맵 인덱스: 이 유형의 인덱스는 부울 또는 열거형 열과 같이 소수의 고유 값이 있는 열에 사용됩니다. 비트맵 인덱스는 여러 열을 포함하는 쿼리 술어에 특히 효율적입니다.
4. 전체 텍스트 인덱스: 이 유형의 인덱스는 대용량 텍스트 문서를 저장하는 열에 사용되며 키워드 또는 구문을 기반으로 텍스트 데이터를 효율적으로 검색하고 가져올 수 있습니다.
5. 공간 인덱스: 이 유형의 인덱스는 지리적 또는 기하학적 데이터와 같은 공간 데이터를 저장하는 열에 사용됩니다. 공간 인덱스는 특정 거리 내의 점 찾기 또는 지정된 영역과 교차하는 다각형 찾기와 같은 공간 쿼리에 최적화되어 있습니다.

RDBMS의 인덱싱은 추가 데이터 구조와 유지 관리 오버헤드가 수반되기 때문에 단순히 테이블에 데이터를 저장하는 것과는 다릅니다. 그러나 쿼리 성능을 크게 향상시키고 큰 테이블에서 데이터를 검색하는 데 필요한 시간을 줄일 수 있습니다. 최적의 성능을 달성하려면 응용 프로그램의 특정 요구 사항 및 쿼리 패턴을 기반으로 적절한 인덱스를 신중하게 계획하고 선택하는 것이 중요합니다.
```
* ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?
```
ORM(Object-Relational Mapping)은 객체 지향 프로그래밍 언어 구조를 관계형 데이터베이스 개념에 매핑하기 위해 소프트웨어 개발에 사용되는 기술입니다. Hibernate, Entity Framework 및 Django ORM과 같은 ORM 프레임워크는 개발자가 원시 SQL 쿼리를 작성하는 대신 개체 지향 코드를 사용하여 데이터베이스와 상호 작용할 수 있는 추상화 계층을 제공합니다. 다음은 ORM을 사용하지 않을 때와 비교할 때 장단점입니다.

ORM 사용의 장점:

1. 단순화되고 추상화된 데이터베이스 상호 작용: ORM 프레임워크는 데이터베이스와 상호 작용하는 더 높은 수준의 추상화된 방법을 제공하여 개발자가 원시 SQL 쿼리를 처리하는 대신 객체 및 클래스로 작업할 수 있도록 합니다. 이렇게 하면 특히 개체 지향 프로그래밍에 더 익숙한 개발자의 경우 코드베이스를 보다 유지 관리하기 쉽고 이해하기 쉽게 만들 수 있습니다.
2. 이식성 및 데이터베이스 독립성: ORM 프레임워크는 종종 개발자가 최소한의 코드 변경으로 다른 데이터베이스(예: MySQL, PostgreSQL 및 SQLite) 간에 전환할 수 있는 추상화 계층을 제공합니다. 이를 통해 프로젝트 또는 조직의 요구 사항에 따라 데이터베이스를 선택하고 전환할 때 유연성을 높일 수 있습니다.
3. 생산성 및 더 빠른 개발: ORM 프레임워크는 CRUD(만들기, 읽기, 업데이트, 삭제) 작업, 트랜잭션 및 쿼리 작성과 같은 일반적인 데이터베이스 작업을 추상화하여 생산성 향상을 제공할 수 있습니다. 이는 개발자가 반복적인 데이터베이스 관련 코드를 작성할 필요가 없기 때문에 개발 시간과 노력을 절약할 수 있습니다.
4. SQL 인젝션 취약점 감소: ORM 프레임워크는 일반적으로 원시 SQL 쿼리를 직접 실행하는 애플리케이션의 일반적인 보안 취약점일 수 있는 SQL 인젝션 공격으로부터 보호하기 위한 기본 제공 메커니즘을 제공합니다. ORM 프레임워크는 일반적으로 SQL 삽입 공격을 방지하기 위해 사용자 입력의 이스케이프를 자동으로 처리하는 매개변수화된 쿼리 또는 준비된 명령문을 사용합니다.

ORM 사용의 단점:

1. 성능 오버헤드: ORM 프레임워크는 원시 SQL 쿼리를 작성하는 것과 비교하여 성능 오버헤드를 추가할 수 있는 추가 추상화 계층을 도입합니다. ORM 프레임워크는 복잡한 SQL 쿼리를 생성하는 경우가 많으며 특정 경우, 특히 복잡한 쿼리 또는 트랜잭션 속도가 높은 애플리케이션의 경우 성능이 수동으로 최적화된 SQL 쿼리만큼 최적이 아닐 수 있습니다.
2. 데이터베이스 최적화에 대한 제한된 제어: ORM 프레임워크는 기본 데이터베이스 최적화 및 기능을 추상화하여 데이터베이스별 인덱싱, 저장 프로시저 또는 고급 쿼리 최적화와 같은 고급 데이터베이스 기능을 활용하기 어렵게 만듭니다. 이로 인해 원시 SQL 쿼리로 달성할 수 있는 성능 최적화가 제한될 수 있습니다.
3. 학습 곡선 및 복잡성: ORM 프레임워크에는 종종 학습 곡선이 있으며 특히 관계형 데이터베이스 또는 ORM 프레임워크의 개념에 익숙하지 않은 개발자의 경우 개발 프로세스에 복잡성을 추가할 수 있습니다. 개발 프로세스에 학습 곡선을 추가할 수 있는 ORM 프레임워크의 구문, 구성 및 사용법을 배워야 할 수도 있습니다.
4. 사용자 지정 제한: ORM 프레임워크는 특정 데이터베이스의 모든 고급 또는 사용자 지정 기능을 지원하지 않거나 사용자 지정 또는 확장성 측면에서 제한이 있을 수 있습니다. 이로 인해 개발자는 복잡하고 오류가 발생하기 쉬운 경우에 원시 SQL 쿼리를 작성하거나 ORM 프레임워크를 우회해야 할 수 있습니다.

요약하면 ORM을 사용하면 단순화된 데이터베이스 상호 작용, 이식성, 생산성 및 향상된 보안과 같은 이점을 제공할 수 있습니다. 그러나 성능 오버헤드, 사용자 지정 제한 및 추가 복잡성이 발생할 수도 있습니다. ORM 사용 여부에 대한 결정은 성능 고려 사항, ORM에 대한 팀의 친숙도, 사용자 지정 또는 고급 데이터베이스 기능의 필요성을 포함하여 프로젝트의 특정 요구 사항 및 장단점에 따라 달라집니다.
```
  * 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?
  ```
  JavaScript 코드를 사용하여 데이터베이스와 상호 작용하기 위한 추상화 계층을 제공하는 JavaScript 에코시스템에서 사용할 수 있는 여러 ORM(Object-Relational Mapping) 라이브러리가 있습니다. JavaScript 생태계에서 인기 있는 ORM 라이브러리는 다음과 같습니다.
  
  1. Sequelize: Sequelize는 MySQL, PostgreSQL, SQLite 및 MSSQL을 비롯한 여러 데이터베이스를 지원하는 Node.js 및 JavaScript용으로 널리 사용되는 ORM입니다. 모델, 관계를 정의하고 CRUD 작업을 수행하기 위한 강력하고 유연한 API를 제공합니다.
  2. TypeORM: TypeORM은 MySQL, PostgreSQL, SQLite 및 MSSQL을 비롯한 여러 데이터베이스를 지원하는 Node.js 및 JavaScript용으로 널리 사용되는 또 다른 ORM입니다. 엔터티, 관계를 정의하기 위한 데코레이터 기반 구문을 제공하고 마이그레이션, 캐싱 및 트랜잭션과 같은 고급 기능을 지원합니다.
  3. 몽구스(Mongoose): 몽구스는 NoSQL 데이터베이스인 MongoDB용 인기 ORM입니다. 스키마, 모델을 정의하고 JavaScript 또는 TypeScript를 사용하여 MongoDB 데이터베이스를 쿼리하기 위한 간단하고 직관적인 API를 제공합니다.
  4. Waterline: Waterline은 MySQL, PostgreSQL, MongoDB 등 여러 데이터베이스를 지원하는 Node.js용 다목적 ORM입니다. 모델, 관계를 정의하기 위한 데이터 기반 구문을 제공하고 다양한 데이터베이스에 연결하기 위한 유효성 검사, 수명 주기 후크 및 어댑터와 같은 고급 기능을 지원합니다.
  5. Bookshelf: Bookshelf는 MySQL, PostgreSQL 및 SQLite와 같은 관계형 데이터베이스와 상호 작용하기 위한 간단하고 표현력이 풍부한 API를 제공하는 Node.js용 경량 ORM입니다. 모델 정의, 관계 및 트랜잭션과 같은 기능을 지원합니다.
  6. Objection.js: Objection.js는 SQL 데이터베이스용 쿼리 빌더인 Knex.js를 기반으로 구축된 또 다른 인기 있는 Node.js용 ORM입니다. Objection.js는 JavaScript 또는 TypeScript를 사용하여 모델, 관계 및 쿼리 SQL 데이터베이스를 정의하기 위한 간단하고 강력한 API를 제공합니다.
  
  이는 JavaScript 생태계에서 사용할 수 있는 많은 ORM 라이브러리의 몇 가지 예일 뿐입니다. ORM의 선택은 프로젝트의 특정 요구 사항, 사용 중인 데이터베이스, ORM 및 해당 기능에 대한 개발 팀의 친숙도에 따라 다릅니다.
  ```
* 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?
```
ORM(Object-Relational Mapping) 컨텍스트에서 1:1, 1:N 및 N:M은 관계형 데이터베이스의 모델 또는 엔터티 간의 서로 다른 유형의 관계를 설명하는 일반적으로 사용되는 용어입니다.

1:1(일대일) 관계: 1:1 관계에서 한 테이블(테이블 A)의 각 레코드는 다른 테이블(테이블 B)의 정확히 하나의 레코드와 연관되며 그 반대의 경우도 마찬가지입니다. 이는 두 테이블 간의 관계가 고유하고 일대일임을 의미합니다. 예를 들어, 학교 데이터베이스에서 "Student" 테이블과 "StudentInfo" 테이블은 1:1 관계를 가질 수 있습니다. 여기서 각 학생은 고유한 학생 정보 레코드가 연결되어 있고 각 학생 정보 레코드는 다음과 연결되어 있습니다. 단 한 명의 학생. 이러한 유형의 관계는 두 엔터티가 엄격한 일대일 대응을 갖고 중복을 방지하고 데이터 무결성을 유지하기 위해 해당 속성을 별도의 테이블로 분리하는 것이 바람직할 때 사용됩니다.

1:N(일대다) 관계: 1:N 관계에서 한 테이블(테이블 A)의 각 레코드는 다른 테이블(테이블 B)의 하나 이상의 레코드와 연결되지만 테이블 B의 각 레코드는 예를 들어 전자 상거래 사이트의 데이터베이스에서 "Customer" 테이블과 "Order" 테이블은 1:N 관계일 수 있습니다. 여기서 각 고객은 여러 주문을 할 수 있지만 각 주문은 한 명의 고객과만 연결됩니다. 이 유형의 관계는 하나의 엔터티가 여러 관련 엔터티를 가질 수 있지만 각 관련 엔터티는 하나의 엔터티에만 연결되는 경우에 사용됩니다.

N:M(다대다) 관계: N:M 관계에서 한 테이블(테이블 A)의 레코드는 다른 테이블(테이블 B)의 여러 레코드와 연결될 수 있으며 그 반대의 경우도 마찬가지입니다. 이는 두 테이블 간의 관계가 다대다임을 의미합니다. 예를 들어 소셜 미디어 플랫폼용 데이터베이스에서 "사용자" 테이블과 "게시물" 테이블은 N:M 관계를 가질 수 있습니다. 여기서 각 사용자는 여러 게시물을 가질 수 있고 각 게시물은 여러 사용자(예: 좋아요)를 가질 수 있습니다. , 댓글, 공유). 이 유형의 관계는 여러 엔터티가 다른 여러 엔터티와 연결될 수 있는 경우에 사용됩니다.

ORM은 개체 지향 프로그래밍 개념을 사용하여 데이터베이스의 모델 또는 엔터티 간의 이러한 관계를 정의하고 처리하는 기능을 제공합니다. 이러한 관계는 복잡한 데이터 시나리오를 모델링하고 데이터베이스에서 관련 데이터를 효율적으로 검색하는 데 도움이 됩니다.
```
* DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
```
"해싱" 및 "솔팅"이라는 프로세스를 사용하여 데이터베이스에 일반 텍스트로 사용자 암호를 저장하지 않고도 사용자 암호를 인증할 수 있습니다.

해싱은 입력(이 경우 사용자 암호)을 받아 고정 크기의 문자열(일반적으로 16진수 또는 base64 인코딩 문자열)을 생성하는 단방향 함수입니다. 해시라고 하는 출력은 입력에 대해 고유하므로 입력이 조금만 변경되어도 상당히 다른 해시가 생성됩니다. 그러나 동일한 입력은 항상 동일한 해시를 생성합니다.

솔트는 각 사용자에 대해 생성된 임의의 값이며 해싱 전에 암호에 추가됩니다. 그런 다음 소금은 해시와 함께 데이터베이스에 저장됩니다. 사용자가 로그인을 시도하면 입력한 비밀번호에 동일한 솔트가 추가되고 결과 값이 해시되어 저장된 해시와 비교됩니다. 계산된 해시가 저장된 해시와 일치하면 암호가 유효한 것으로 간주되고 사용자가 인증됩니다.

해싱 및 솔팅을 사용하면 다음과 같은 몇 가지 보안 이점이 있습니다.

암호 공격으로부터 보호: 암호를 데이터베이스에 일반 텍스트로 저장하면 데이터 유출 시 공격자가 사용자 계정에 쉽게 액세스할 수 있으므로 보안 위험이 있습니다. 해싱 및 솔팅은 공격자가 저장된 해시에서 원래 비밀번호를 리버스 엔지니어링하는 것을 극도로 어렵게 만들어 레인보우 테이블 공격 또는 무차별 대입 공격과 같은 비밀번호 공격을 훨씬 더 어렵게 만듭니다.
해시의 개별성: 각 사용자에 대해 고유한 솔트를 사용하여 해싱하면 두 명의 사용자가 동일한 암호를 가지고 있더라도 다른 솔트를 사용하기 때문에 저장된 해시가 달라집니다. 이는 동일한 암호를 사용하는 여러 계정을 대상으로 하는 공격으로부터 보호합니다.
일반 텍스트 암호를 저장하지 않고 확인: 해싱을 사용하면 실제 암호를 일반 텍스트로 저장하지 않고 암호를 확인할 수 있으며 이는 보안 모범 사례로 간주됩니다. 이는 실제 암호가 데이터베이스에 저장되지 않도록 하여 데이터 위반 및 무단 액세스의 위험을 줄여 사용자 개인 정보를 보호합니다.

요약하면 해싱과 솔팅을 사용하면 암호를 데이터베이스에 일반 텍스트로 저장하지 않고도 사용자의 암호를 인증할 수 있으므로 사용자 계정과 민감한 정보를 보호하기 위한 추가 보안 계층을 제공합니다.
```
  * 해시 함수에는 어떤 것이 있나요?
  ```
  해시 함수는 입력(일반적으로 모든 크기의 메시지 또는 데이터)을 받아 고정 크기 출력, 일반적으로 고정 길이 문자열 또는 바이트를 생성하는 수학적 알고리즘 또는 단방향 함수입니다. 해시 또는 해시 값으로 알려진 출력은 입력 데이터의 고유한 표현이며 입력 데이터의 작은 변경조차도 상당히 다른 해시 값을 생성합니다.
  
  해시 함수는 데이터 무결성 확인, 디지털 서명, 암호 저장 및 메시지 인증을 포함하여 컴퓨터 과학 및 정보 보안의 다양한 영역에서 일반적으로 사용됩니다. 계산 속도가 빠르고 각각의 고유한 입력 데이터에 대해 고유한 해시 값을 생성하도록 설계되어 데이터 비교, 데이터 저장 및 데이터 검색과 같은 작업에 유용합니다.
  
  해시 함수에는 몇 가지 중요한 속성이 있습니다.
  
  1. 결정론적: 주어진 입력은 항상 동일한 해시 값을 생성합니다. 이 속성은 동일한 데이터를 여러 번 해싱할 때 일관되고 반복 가능한 결과를 허용합니다.
  2. 고정 크기 출력: 해시 함수는 입력 데이터의 크기에 관계없이 고정 크기 출력을 생성합니다. 따라서 고정된 저장 공간을 사용하여 많은 양의 데이터를 저장하고 비교하는 데 효율적입니다.
  3. 단방향: 해시 함수는 계산상 반전이 불가능하도록 설계되었습니다. 즉, 해시 값에서 원래 입력 데이터를 재구성하는 것이 불가능하지는 않더라도 극히 어렵습니다.
  4. 고유한 해시 값: 해시 함수는 다른 입력 데이터에 대해 고유한 해시 값을 생성해야 합니다. 입력 데이터가 조금만 변경되어도 해시 값이 크게 달라집니다. 이 속성은 해시 함수를 데이터 무결성의 사소한 변화도 감지하는 데 적합하게 만듭니다.
  5. 충돌 저항성: 해시 함수는 다른 입력 데이터에 대해 동일한 해시 값을 생성(충돌)하지 않아야 합니다. 두 개의 서로 다른 입력이 동일한 해시 값(충돌)을 생성하는 것이 이론적으로 가능하지만 좋은 해시 함수는 충돌 가능성을 최소화합니다.
  
  해시 함수는 데이터 무결성, 인증 및 디지털 서명을 안전하게 표현하고 확인하는 방법을 제공하는 많은 암호화 및 보안 응용 프로그램의 기본 빌딩 블록입니다.
  ```
  * 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?
  ```
  보안을 위해 사용자의 비밀번호를 해싱하여 저장할 때 강력한 해싱 알고리즘, 사용자별 고유 솔트, 여러 번의 해시 함수 반복을 조합하여 사용하여 보안을 강화하는 것이 좋습니다. 일반적으로 "해싱 및 솔팅(hashing and salting)"으로 알려진 이 접근 방식은 암호 공격으로부터 보호하고 저장된 암호 해시가 더 잘 깨지지 않도록 합니다.
  
  다음은 해싱 및 솔팅을 사용하여 사용자 비밀번호를 안전하게 저장하는 몇 가지 모범 사례입니다.
  
  1. 강력한 해싱 알고리즘 사용: bcrypt, scrypt 또는 Argon2와 같이 암호 해싱을 위해 특별히 설계되었으며 무차별 암호 대입 공격 및 레인보우 테이블 공격을 포함한 다양한 암호 공격에 저항하는 널리 인식되고 암호학적으로 안전한 해시 기능을 선택합니다. .
  2. 각 사용자에 대해 고유한 솔트 생성: 각 사용자에 대해 임의의 고유한 솔트를 생성하고 암호 해시와 함께 저장합니다. 솔트는 길고 예측 불가능하며 암호학적으로 안전해야 합니다. 이렇게 하면 동일한 암호를 가진 사용자라도 다른 솔트를 사용하기 때문에 다른 해시를 갖게 되어 동일한 암호를 가진 여러 계정을 대상으로 하는 공격으로부터 보호할 수 있습니다.
  3. 다중 반복(작업 요소) 사용: 암호를 해싱할 때 다중 반복 또는 "작업 요소"를 사용하여 해시 함수의 계산 비용을 증가시킵니다. 이로 인해 공격자가 무차별 암호 대입 공격이나 레인보우 테이블 공격을 통해 암호 해시를 크래킹하는 데 더 많은 시간과 리소스가 필요합니다.
  4. "페퍼" 사용 고려: 페퍼는 해싱 전에 암호에 추가되고 데이터베이스에 저장되지 않는 비밀 키입니다. 이렇게 하면 공격자가 유효한 해시를 생성하기 위해 후추를 알아야 하므로 해시 값과 솔트에 대한 액세스 권한을 얻더라도 암호를 해독하기가 더 어려워지므로 추가 보안 계층이 추가됩니다.
  5. 해싱 방법을 정기적으로 검토 및 업데이트: 암호 해싱에 대한 최신 모범 사례를 최신 상태로 유지하고 주기적으로 구현을 검토 및 업데이트하여 진화하는 암호 공격 및 암호화 취약점으로부터 안전하게 유지되도록 합니다.
  6. 기타 보안 조치 구현: 해싱 및 솔팅만으로는 사용자 암호에 대한 완전한 보안을 제공할 수 없습니다. 보안 통신을 위해 HTTPS를 사용하고, 강력한 인증 메커니즘을 사용하고, 사용자 계정과 중요한 정보를 보호하기 위해 기타 보안 모범 사례를 따르는 것과 같은 다른 보안 조치를 구현하는 것이 필수적입니다.
  
  이러한 모범 사례를 따르면 사용자 암호를 안전하게 해시하고 저장하여 사용자 계정에 대한 무단 액세스 위험을 줄이고 중요한 사용자 정보를 보호할 수 있습니다.
  ```

## Quest
* 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  * 적절한 테이블을 설계해 보세요.
  * Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  * 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced
* Object–relational impedance mismatch란 어떤 개념인가요?
* Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
* 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
