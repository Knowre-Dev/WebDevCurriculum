# Quest 16-B. 컨테이너

## Introduction
* 이번 퀘스트에서는 컨테이너 기술과 그 활용에 대해 알아보겠습니다.

## Topics
* 컨테이너 기술
* Docker
* docker-compose

## Resources
* [#LearnDocker](https://www.docker.com/101-tutorial)
* [Docker Tutorial for Beginners](https://docker-curriculum.com/)
* [docker-compose](https://docs.docker.com/compose/)

## Checklist
* 컨테이너는 어떻게 동작하나요? 다른 배포판을 사용할 수 있게 하는 원리가 무엇일까요?
```
컨테이너는 라이브러리, 런타임 및 시스템 도구를 포함하여 응용 프로그램 및 해당 종속성을 단일 실행 가능 단위로 캡슐화하는 가볍고 휴대 가능하며 자급자족할 수 있는 소프트웨어 패키지입니다. 컨테이너는 Docker와 같은 컨테이너화 기술을 사용하여 애플리케이션이 개발 머신, 테스트 환경 및 프로덕션 서버와 같은 다양한 컴퓨팅 환경에서 일관되게 실행될 수 있는 격리된 환경을 만듭니다.

컨테이너가 다른 배포판(또는 운영 체제)에서 작동하도록 허용하는 원칙을 "컨테이너화" 또는 "OS 수준 가상화"라고 합니다. 컨테이너화는 컨테이너가 동일한 호스트 OS 커널을 공유하지만 별도의 사용자 공간 인스턴스를 갖는 운영 체제(OS) 수준에서 작동하는 가상화의 한 형태입니다. 컨테이너는 호스트 OS 커널을 활용하여 격리된 파일 시스템, 네트워크 인터페이스 및 각 컨테이너에 대한 프로세스 트리를 제공하는 동시에 CPU, 메모리 및 스토리지와 같은 기본 OS 리소스를 효율적으로 공유합니다.

컨테이너는 작업을 위해 호스트 OS 커널에 의존하기 때문에 특정 배포 또는 OS에 연결되지 않습니다. 이는 컨테이너가 수정 없이 Ubuntu, CentOS 또는 Debian과 같은 다양한 배포에서 일관된 방식으로 종속성과 함께 패키징된 애플리케이션을 실행할 수 있음을 의미합니다. 컨테이너는 기본 호스트 OS에 관계없이 애플리케이션에 일관된 런타임 환경을 제공하므로 이식성이 뛰어나고 다양한 배포 또는 다양한 클라우드 플랫폼에 애플리케이션을 유연하게 배포할 수 있습니다.

컨테이너가 다양한 배포판에서 작동하도록 하는 핵심 기술은 컨테이너 이미지를 사용하는 것입니다. 컨테이너 이미지는 애플리케이션 코드, 런타임, 라이브러리 및 시스템 도구를 포함하여 소프트웨어를 실행하는 데 필요한 모든 것을 포함하는 경량의 독립 실행형 및 이식 가능한 소프트웨어 패키지입니다. 컨테이너 이미지는 Docker와 같은 컨테이너화 도구에서 생성됩니다. 이를 통해 개발자는 호환 가능한 컨테이너 런타임 환경이 있는 한 애플리케이션과 해당 종속성을 다양한 배포 또는 운영 체제에서 일관되게 실행할 수 있는 단일 이미지로 패키징할 수 있습니다.

컨테이너 이미지는 일반적으로 Docker Hub 또는 Google Container Registry와 같은 컨테이너 레지스트리에 저장되며 호환되는 컨테이너 런타임이 설치된 모든 호스트 시스템에서 쉽게 가져와서 실행할 수 있습니다. 이를 통해 응용 프로그램을 컨테이너 이미지로 패키징하고 배포할 수 있으므로 종속성이나 호환성 문제에 대한 걱정 없이 다양한 배포 또는 운영 체제에서 일관되게 배포하고 실행할 수 있습니다. 컨테이너의 이러한 유연성과 이식성 덕분에 최신 소프트웨어 개발 및 배포 워크플로우에 널리 사용됩니다.
```
* 도커 컨테이너에 호스트의 파일시스템이나 네트워크 포트를 연결하려면 어떻게 해야 할까요?
```
호스트의 파일 시스템을 Docker 컨테이너에 연결:
docker run 명령을 실행할 때 -v 또는 --volume 옵션을 사용하여 호스트의 파일 시스템을 Docker 컨테이너에 연결할 수 있습니다. 이를 통해 호스트의 파일 시스템에서 컨테이너로 디렉터리 또는 파일을 마운트할 수 있으므로 컨테이너에서 읽기/쓰기 작업에 액세스할 수 있습니다.

호스트의 파일 시스템을 Docker 컨테이너에 연결:
docker run 명령을 실행할 때 -v 또는 --volume 옵션을 사용하여 호스트의 파일 시스템을 Docker 컨테이너에 연결할 수 있습니다. 이를 통해 호스트의 파일 시스템에서 컨테이너로 디렉터리 또는 파일을 마운트할 수 있으므로 컨테이너에서 읽기/쓰기 작업에 액세스할 수 있습니다. 

이러한 옵션을 사용하면 호스트의 파일 시스템 또는 네트워크 포트를 Docker 컨테이너에 쉽게 연결할 수 있으므로 호스트와 컨테이너 간에 원활한 통신 및 데이터 공유가 가능합니다. 그러나 잠재적으로 보안 위험이나 충돌이 발생할 수 있으므로 호스트 리소스를 컨테이너에 연결할 때 주의하는 것이 중요하며 Docker 컨테이너로 작업할 때 모범 사례 및 보안 지침을 따르는 것이 좋습니다.
```
* 도커 컨테이너에서 런타임에 환경변수를 주입하려면 어떻게 해야 할까요?
```
Docker에서는 docker run 명령을 실행할 때 -e 또는 --env 옵션을 사용하여 런타임 시 환경 변수를 컨테이너에 주입할 수 있습니다. 방법은 다음과 같습니다.

명령줄에서 환경 변수 주입:
'-e' 옵션 뒤에 변수 이름과 해당 값을 사용하여 명령줄에서 Docker 컨테이너로 환경 변수를 전달할 수 있습니다. 

파일에서 환경 변수 주입:
--env-file 옵션 뒤에 변수가 포함된 파일 경로를 사용하여 파일에서 Docker 컨테이너로 환경 변수를 전달할 수도 있습니다.

이러한 옵션을 사용하면 런타임에 환경 변수를 Docker 컨테이너에 동적으로 주입하여 컨테이너 이미지 자체를 수정하지 않고도 컨테이너의 동작 또는 구성을 사용자 지정할 수 있습니다. 런타임에 삽입된 환경 변수는 현재 세션의 컨테이너 내에서만 사용할 수 있으며 컨테이너를 다시 시작할 때에도 변수를 유지해야 하는 경우 Docker 볼륨 또는 구성 파일과 같은 다른 메커니즘을 사용해야 할 수 있습니다.
```
* 도커 컨테이너의 stdout 로그를 보려면 어떻게 해야 할까요?
```
docker logs 명령을 사용하여 Docker 컨테이너의 stdout(표준 출력) 로그를 볼 수 있습니다. 방법은 다음과 같습니다.

실행 중인 컨테이너에 대한 stdout 로그 보기:
Docker 컨테이너가 현재 실행 중인 경우 다음 명령을 사용하여 해당 stdout 로그를 볼 수 있습니다.

>> docker logs <container_name_or_id>
<container_name_or_id>를 보려는 stdout 로그가 있는 컨테이너의 이름 또는 ID로 바꿉니다.

중지된 컨테이너에 대한 stdout 로그 보기:
Docker 컨테이너가 이미 중지된 경우에도 docker logs 명령을 사용하여 stdout 로그를 볼 수 있습니다. 그러나 --since 옵션 뒤에 타임스탬프를 지정하여 로그를 보려는 시간 범위를 지정해야 합니다.

>> docker logs --since <timestamp> <container_name_or_id>
<timestamp>를 로그 보기 시작 시간을 나타내는 유효한 타임스탬프로 바꾸고 <container_name_or_id>를 stdout 로그를 보려는 중지된 컨테이너의 이름 또는 ID로 바꿉니다.

docker logs 명령을 사용하면 컨테이너의 출력 및 동작을 문제 해결, 디버깅 또는 모니터링하는 데 도움이 될 수 있는 Docker 컨테이너의 stdout 로그를 쉽게 볼 수 있습니다. stdout 로그는 컨테이너의 표준 출력 스트림만 캡처하며 stderr(표준 오류) 또는 컨테이너 내에서 실행 중인 특정 프로세스의 로그와 같은 다른 로그를 확인해야 하는 경우 컨테이너와 같은 다른 메커니즘을 사용해야 할 수 있습니다. 로깅 드라이버 또는 구성 옵션.
```
* 실행중인 도커 컨테이너에 들어가 bash 등의 쉘을 실행하고 로그 등을 보려면 어떻게 해야 할까요?
```
실행 중인 Docker 컨테이너에 들어가 Bash와 같은 셸을 실행하고 로그를 보려면 docker exec 명령을 사용할 수 있습니다. 방법은 다음과 같습니다.

실행 중인 컨테이너에 들어가기:
다음 명령을 사용하여 실행 중인 Docker 컨테이너에 들어가 Bash와 같은 셸을 열 수 있습니다.

>> docker exec -it <container_name_or_id> bash
<container_name_or_id>를 액세스하려는 실행 중인 컨테이너의 이름 또는 ID로 바꿉니다. -it 옵션은 pseudo-TTY를 할당하고 컨테이너의 stdin, stdout 및 stderr에 연결하는 데 사용되며 bash 명령은 컨테이너 내에서 Bash 셸을 시작하는 데 사용됩니다.

실행 중인 컨테이너에서 로그 보기:
실행 중인 Docker 컨테이너의 로그를 보려면 다음 명령을 사용할 수 있습니다.

>> docker logs -f <container_name_or_id>
<container_name_or_id>를 로그를 보려는 실행 중인 컨테이너의 이름 또는 ID로 바꿉니다. -f 옵션은 실시간으로 로그를 스트리밍하는 데 사용되며 생성된 최신 로그를 볼 수 있습니다.

docker exec 및 docker logs 명령을 사용하면 실행 중인 Docker 컨테이너에 쉽게 액세스하고 Bash와 같은 셸을 실행하여 명령을 실행하고 문제 해결 또는 모니터링 목적으로 로그를 보는 등 컨테이너와 상호 작용할 수 있습니다. 이러한 명령을 사용하려면 컨테이너에 대한 적절한 권한 및 액세스 권한이 있어야 하며 특정 기능 또는 로그의 가용성은 컨테이너 이미지 또는 Docker 런타임 환경의 구성에 따라 달라질 수 있습니다.
```

## Quest
* 도커를 설치하고 그 사용법을 익혀 보세요.
* 메모장 시스템 서버를 컨테이너 기반으로 띄울 수 있게 수정해 보세요. (docker-compose는 사용하지 않습니다)
* 컨테이너를 Docker Hub에 올리고, 발급받은 학습용 AWS 계정에 EC2 인스턴스를 생성한 뒤, 해당 컨테이너를 띄워서 서비스 해 보세요.
* docker-compose를 사용하여, 이미지 빌드와 서버 업/다운을 쉽게 할 수 있도록 고쳐 보세요.

## Advanced
* 도커 외의 컨테이너 기술의 대안은 어떤 것이 있을까요?
* 맥이나 윈도우에서도 컨테이너 기술을 사용할 수 있는 원리는 무엇일까요?
