# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist

- RDBMS 테이블의 정규화는 무엇인가요?
  ```
  >RDBMS(Relational DataBase Management System)를 설계할 때,
   중복을 최소화하면서 데이터 구조를 짜는 프로세스이다.
  ```
- MySQL 외의 RDB에는 어떤 것들이 있나요?

  ```
  1.Oracle: 대규모 비즈니스 애플리케이션을 위해 설계된 강력한 RDBMS입니다. 높은 안정성과 확장성을 제공하며,
  다양한 운영 체제와 하드웨어 플랫폼에서 실행될 수 있습니다.

  2.Microsoft SQL Server: Microsoft에서 제공하는 RDBMS입니다. Windows 운영 체제에서 실행될 수 있으며,
  대규모 비즈니스 애플리케이션을 위해 설계되었습니다.

  3.PostgreSQL: 오픈 소스 RDBMS로, 안정성과 확장성이 높습니다. 다양한 운영 체제에서 실행될 수 있으며,
  다양한 기능을 제공합니다.

  4.SQLite: 경량 RDBMS로, 단일 파일로 데이터베이스를 관리합니다. 모바일 디바이스 및
   웹 브라우저에서 작동하기에 적합합니다.
  ```

  - Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?

  ```
  1.NoSQL 데이터베이스 NoSQL 데이터베이스는 관계형 데이터베이스와 달리 스키마가 없거나
  유연한 스키마를 가지고 있습니다. 데이터는 다양한 형식으로 저장될 수 있으며,
  일반적으로 대량의 비정형 데이터를 처리하는 데 사용됩니다.
  예를 들어, MongoDB, Cassandra, Redis 등이 있습니다.

  2. 그래프 데이터베이스 그래프 데이터베이스는 데이터를 노드(node)와 엣지(edge)로
  구성된 그래프 형식으로 저장합니다. 이러한 구조는 연결된 데이터를 쉽게 검색하고
   분석할 수 있으므로, 소셜 미디어, 추천 시스템, 지리 정보 시스템 등에 자주 사용됩니다.
   예를 들어, Neo4j, OrientDB 등이 있습니다.

  3. 객체 지향 데이터베이스 객체 지향 데이터베이스는 객체 지향 프로그래밍에서 사용되는
  객체를 데이터베이스에 저장하는 방식입니다. 이러한 데이터베이스는 복잡한 객체를
  쉽게 저장하고 관리할 수 있으며, 객체 간의 관계를 쉽게 모델링할 수 있습니다.
  예를 들어, db4o, Versant 등이 있습니다.

  4. 키-값 스토어 키-값 스토어는 키와 값을 쌍으로 저장하는 단순한 데이터베이스입니다.
  이러한 데이터베이스는 분산 시스템과 클라우드 컴퓨팅에 적합합니다.
  예를 들어, Riak, Amazon DynamoDB, Apache Cassandra 등이 있습니다.
  ```

- RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

```
> 인덱싱은 데이터 베이스 내의 테이블에서 레코드들을 빠르게
검색하기 위한 기술.
> 인덱싱을 사용하면 데이터베이스는 검색을 수행할 때 전체
테이블을 스캔 하지 않고 인덱스를 사용하여 필요한 레코드를
더 빠르게 찾을 수 있음.
> 인덱스는 일반적으로 B-tree 또는 B+tree 알고리즘을 사용하여
구현된다. 이러한 알고리즘은 인덱스키를 기반으로 트리 구조를
맏늘어 빠른 검색이 가능.
> 인덱스는 데이터베이스 성능을 향상시키는데 중요한 역할 수행.
```

- ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?

```
 장점 :
 1. 완벽한 객체지향적인 코드-> 직관적인 이해가 쉬움
  : ORM을 이용하면 SQL문이 아닌 클래스의 메서드를 통해
   데이터베이스 조작할 수 있어, 개발자가 객체 모델만 이용해서
   프로그래밍을 하는데 집중 할 수 있음.
 2. 재사용, 유지보수, 리팩토링의 용이성
  : ORM을 통해 작성한 객체를 재활용할 수 있다는 측면에서
  재사용 및 유지보수의 편리성이 증가.
 3. DBMS 종속성 하락
  : 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하고, 객체의 자료형 타입까지 사용할 수 있기 때문에 RDBMS의
  데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있다.
  객체에만 집중할 수 있기 때문에 DBMS를 교체하는 큰 작업에도
  리스크가 적고 드는 시간도 줌.

  단점:
  1.ORM이 모든 걸 해결해줄 수 없다. -> 적절하게 SQL문을 사용할 수 있어야한다.
   : 프로젝트의 복잡성이 커질 수록 난이도도 올라가고 부족한 설계로 잘못 구현되었을 경우 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다. 또한 일부 자주 사용되는 대형 SQL문은 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있다.
  2. 복잡한 쿼리문의 경우 오히려 SQL문으로 사용이 직관적이면서 효율적일 수 있다.
```

- 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?

```
1. Sequelize: Sequelize는 Node.js 기반 ORM으로, MySQL, PostgreSQL, SQLite, MSSQL 등의 데이터베이스와 호환됩니다.

2. Mongoose: Mongoose는 MongoDB에 대한 객체 데이터 모델링(Object Data Modeling)을 지원하는 ORM입니다.

3. TypeORM: TypeORM은 TypeScript와 함께 사용하는 ORM으로, MySQL, PostgreSQL, SQLite, MSSQL, Oracle 등의 데이터베이스를 지원합니다.

4. Waterline: Waterline은 Node.js ORM으로, NoSQL 및 관계형 데이터베이스에서 작동합니다. MongoDB, MySQL, PostgreSQL, Redis 등을 지원합니다.

5. Bookshelf.js: Bookshelf.js는 Node.js ORM으로, MySQL, PostgreSQL, SQLite, MSSQL 등의 데이터베이스와 호환됩니다.

6. Objection.js: Objection.js는 Node.js ORM으로, PostgreSQL, MySQL, SQLite3, MSSQL 등의 데이터베이스를 지원합니다.

7. Prisma: Prisma는 TypeScript를 사용하여 데이터베이스에 대한 타입 안전한 ORM을 제공합니다. PostgreSQL, MySQL, SQLite, MS SQL Server 등의 데이터베이스를 지원합니다.


```

- 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?

```
 > 관계는 두 엔티티가 서로 관련이 있을 때를 말하는데, 1:1, 1:N, N:M 관계를 맺을 수 있다.
 > 1:1 관계란 어느 엔티티 쪽에서 상대 엔티티와 반드시 단 하나의 관계를 가지는 것을 말한다.
 > 1:N 관계는 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미한다.
  현실세계에는 1:N관계가 많이 있는데, 실제 DB를 설계할 때 자주 쓰이는 방식이다.
  1:N 관계는 N:M 관계처럼 새로운 테이블을 만들지 않는다.
> N:M 관계는 관계를 가진 양쪽 엔티티 모두에서 1:N 관계를 가지는 것을 말한다.

즉, 서로가 서로를 1:N 관계로 보고 있는 것이다.


```

>

- DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?

```
 > 암호는 일반적으로 데이터베이스에 저장되기전에 해시된다.
 해싱은 입력을 받아 고정 크기 출력을 생성하는 단뱡향 프로세스이다.
 >해시는 입력에 고유하므로 입력이 조금만 변경되어도 완전히 다른 해시가 생성된다.
  > 이로 인해 해시의 입력을 리버스 엔지니어링 하기 매우 어렵다.
그래서 사용자 암호를 데이터 베이스에 일반 텍스트로 저장하지
않고도 보안 인증이 가능하다. 공격자가 데이터베이스에 대한
액세스 권한을 얻더라도 암호는 해시된 값으로만 저장되기 때문에
암호를 읽고 이를 사용하여 사용자 계정에 액세스 x
```

- 해시 함수에는 어떤 것이 있나요?

```
> 해시 함수는 임이의 길이를 갖는 메시지를 입력받아 고정된 길이의 해시값을 출력하는 함수
>Division (제산법)
Mid – Square (제곱법)
Digit Analysis (숫자 분석법)
Shifting (이동법)
Radix Conversion (기수 변환법)
Folding (중첩법)
Pseudo Random (난수 생성법)
SHA-1
SHA-256
SHA-384
SHA-512
```

- 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?

```
> 사용자 암호를 해싱하고 저장할 때 보안을 위해 암호를 저장하는 가장 좋은 방법은 bcrypt, scrypt 또는 Argon2와 같은 강력한 해싱 알고리즘을 사용하는 것
> bcrypt, scrypt 또는 Argon2와 같은 강력하고 느린 해싱 알고리즘을 사용.
> 각 암호에 대해 고유한 솔트를 사용.
> 적절한 액세스 제어 및 암호화를 사용하여 비밀번호 데이터베이스를 안전하게 유지.
```

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?
- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
