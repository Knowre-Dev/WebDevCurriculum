# Quest 09. 서버와 클라이언트의 대화

## Introduction
* 이번 퀘스트에서는 서버와 클라이언트의 연동, 그리고 웹 API의 설계 방법론 중 하나인 REST에 대해 알아보겠습니다.

## Topics
* expressJS, fastify
* AJAX, `XMLHttpRequest`, `fetch()`
* REST, CRUD
* CORS

## Resources
* [Express Framework](http://expressjs.com/)
* [Fastify Framework](https://www.fastify.io/)
* [MDN - Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
* [MDN - XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)
* [REST API Tutorial](https://restfulapi.net/)
* [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete)
* [MDN - CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

## Checklist
* 비동기 프로그래밍이란 무엇인가요?
```
비동기 프로그래밍은 기본 실행 스레드를 차단하지 않고 작업 또는 작업을 동시에 실행할 수 있는 프로그래밍 접근 방식입니다. 전통적인 동기식 프로그래밍에서는 작업이 차례대로 순차적으로 실행되며 프로그램은 다음 작업으로 이동하기 전에 각 작업이 완료될 때까지 기다립니다. 그러나 비동기식 프로그래밍에서는 작업을 독립적으로 시작하고 실행할 수 있으므로 프로그램이 이전 작업이 완료될 때까지 기다리지 않고 다른 작업을 계속 실행할 수 있습니다.

비동기 프로그래밍은 API와 같은 외부 소스에서 데이터 가져오기, 데이터베이스 읽기 또는 쓰기, 시간 소모적인 계산 수행과 같이 작업을 완료하는 데 오랜 시간이 걸릴 수 있는 시나리오에서 특히 유용합니다. 비동기 프로그래밍을 사용하면 프로그램이 비동기 작업의 완료를 기다리는 동안 다른 작업을 계속 수행하거나 사용자 입력에 응답할 수 있으므로 개발자는 보다 효율적이고 반응이 빠른 코드를 작성할 수 있습니다.

비동기 프로그래밍에서 작업은 일반적으로 즉시 반환되는 비동기 작업으로 시작되어 주 실행 스레드가 차단되지 않고 계속될 수 있습니다. 콜백, 약속 및 async/await는 비동기 작업의 결과 또는 오류를 처리하기 위해 비동기 프로그래밍에서 사용되는 일반적인 기술입니다. 비동기 프로그래밍은 최신 웹 개발, 서버 측 프로그래밍 및 동시 작업을 효율적으로 처리해야 하는 기타 응용 프로그램에서 널리 사용됩니다.
```

  * 콜백을 통해 비동기적 작업을 할 때의 불편한 점은 무엇인가요? 콜백지옥이란 무엇인가요?
  ```
  1. 콜백 지옥: 비동기 작업에 콜백을 사용할 때의 주요 문제 중 하나는 "콜백 지옥"의 가능성입니다. 콜백 지옥은 여러 비동기 작업을 순서대로 실행하거나 서로의 결과에 의존해야 할 때 발생할 수 있는 콜백의 중첩 구조를 말합니다. 이로 인해 깊게 중첩되고 읽기 어려운 코드가 생성되어 관리 및 디버깅이 어려워질 수 있습니다.
  2. 콜백 지옥의 예:
  
  javascript

  asyncFunction1(function(result1) {
    asyncFunction2(result1, function(result2) {
      asyncFunction3(result2, function(result3) {
        // ... and so on
        });
        });
        });
        
  3. 가독성 부족: 콜백 기반 코드는 특히 복잡한 논리 또는 오류 처리를 처리할 때 중첩된 콜백의 여러 수준에서 실행 흐름을 정신적으로 추적해야 하기 때문에 읽고 이해하기 어려울 수 있습니다.
  4. 오류 처리: 중첩된 콜백 내에서 발생하는 오류가 제대로 전파되지 않거나 일관되게 처리되지 않을 수 있으므로 오류 처리는 콜백에서 더 어려울 수 있습니다. 이로 인해 버그가 발생하고 디버깅이 더 어려워질 수 있습니다.
  5. 코드 복제: 경우에 따라 콜백 기반 코드는 오류 처리 또는 공통 로직을 여러 콜백에서 반복해야 하므로 유지 관리 오버헤드가 증가하므로 코드 복제로 이어질 수 있습니다.
  6. 확장성: 애플리케이션의 복잡성이 증가하고 비동기 작업의 수가 증가함에 따라 콜백 관리 및 조정이 어려워져 잠재적인 성능 및 확장성 문제가 발생할 수 있습니다.
  
  이러한 단점에도 불구하고 콜백은 특정 시나리오나 소규모 비동기 작업에 여전히 유용할 수 있습니다. 그러나 최신 프로그래밍 언어 및 프레임워크는 이러한 문제를 완화하고 비동기 작업을 처리하기 위한 보다 깨끗하고 유지 관리하기 쉬운 코드를 제공하는 데 도움이 되는 약속 또는 async/await와 같은 대체 접근 방식을 제공하는 경우가 많습니다.
  ```
  * 자바스크립트의 Promise는 어떤 객체이고 어떤 일을 하나요?
  ```
  JavaScript에서 Promise는 비동기 작업의 최종 완료(또는 실패)를 나타내며 더 읽기 쉽고 관리하기 쉬운 비동기 코드를 허용하는 내장 개체입니다. 아직은 나오지 않았지만 언젠가는 해결될 미래의 가치를 담는 그릇입니다.
  약속에는 세 가지 상태가 있습니다.
  1. Pending: Promise가 생성될 때의 초기 상태. 비동기 작업이 아직 진행 중이고 Promise가 결과를 기다리고 있습니다.
  2. 이행됨: 비동기 작업이 성공적으로 완료되고 Promise에 결과 값이 있는 상태입니다. 이행 상태는 "해결됨" 또는 "성공"이라고도 합니다.
  3. 거부됨: 비동기 작업이 실패하거나 오류가 발생하고 Promise에 실패 이유가 있는 상태입니다. 거부된 상태는 "실패"라고도 합니다.

  약속에는 두 가지 주요 방법이 있습니다.

  1. then(): 이 메서드는 Promise가 이행될 때 호출될 Promise에 하나 이상의 콜백("핸들러"라고도 함)을 연결하는 데 사용됩니다. 비동기 작업을 연결하고 성공적인 결과를 처리할 수 있습니다.
  2. catch(): 이 메서드는 Promise가 거부될 때 호출될 Promise에 콜백을 연결하는 데 사용됩니다. 비동기 작업 중에 발생할 수 있는 오류 또는 실패를 처리할 수 있습니다.
  Promise는 JavaScript에서 비동기 작업을 처리하는 보다 체계적이고 조직적인 방법을 제공하여 콜백 지옥을 피하고 더 읽기 쉽고 유지 관리 가능한 코드를 허용합니다. Promise는 최신 JavaScript 개발에서 널리 사용되며 비동기 작업을 효과적으로 처리하기 위해 async/await와 같은 다른 비동기 프로그래밍 기술과 함께 자주 사용됩니다.
  ```
  * 자바스크립트의 `async`와 `await` 키워드는 어떤 역할을 하며 그 정체는 무엇일까요?
  ```
  JavaScript에서 async 및 await는 비동기 프로그래밍을 용이하게 하고 비동기 코드를 더 쉽게 작성하고 읽고 관리할 수 있도록 함께 사용되는 키워드입니다.
  
  async: async 키워드는 함수를 비동기로 선언하는 데 사용됩니다. 비동기 함수는 기본적으로 비동기 작업의 최종 완료(또는 실패)를 나타내는 'Promise'를 반환합니다. 비동기 함수는 주 실행 스레드를 차단하지 않고 실행을 계속하기 전에 일시 중지하고 'Promise'의 해결을 기다릴 수 있는 'await' 표현식을 포함할 수 있습니다.
  await: await 키워드는 async 함수 내에서 Promise의 해결을 기다리는 데 사용됩니다. 'await'가 'Promise'와 함께 사용되면 Promise가 이행되거나 거부될 때까지 비동기 함수의 실행을 일시 중단합니다. Promise가 이행되면 해결된 값이 반환됩니다. 약속이 거부되면 'try...catch' 블록을 사용하여 잡을 수 있는 오류가 발생합니다.
  
  async 및 await를 사용하면 명시적 콜백 또는 then() 메서드 체인이 필요하지 않으므로 비동기 코드를 더 간결하고 읽기 쉽고 구조가 동기 코드와 유사하게 만들 수 있습니다. 이는 콜백 지옥을 피하는 데 도움이 되며 전통적인 try...catch 블록을 사용하여 오류를 잡을 수 있으므로 오류 처리를 더 간단하게 만듭니다.
  
  다음은 JavaScript에서 async 및 await를 사용하는 방법의 예입니다.
  
  javascript
  async function fetchData() {
    try {
      const response = await fetch('https://api.example.com/data'); // Wait for the fetch Promise to resolve
      const data = await response.json(); // Wait for the JSON parsing Promise to resolve
      console.log(data); // Use the resolved data
      } catch (error) {
      console.error('Error fetching data:', error); // Handle any errors that may occur
      }
    }
  이 예에서 fetchData() 함수는 async 키워드를 사용하여 비동기 함수로 선언됩니다. 함수 내에서 await는 fetch() 및 response.json() 약속의 해결을 기다리는 데 사용되어 비동기 작업의 순차적이고 더 읽기 쉬운 실행을 허용합니다. 비동기 작업 중에 발생할 수 있는 모든 오류는 적절한 오류 처리를 위해 try...catch 블록을 사용하여 포착됩니다.
  ```
* 브라우저 내 스크립트에서 외부 리소스를 가져오려면 어떻게 해야 할까요?
```
JavaScript에서는 최신 웹 브라우저에 내장된 fetch() 함수를 사용하여 브라우저 내 스크립트에서 외부 리소스를 가져올 수 있습니다. fetch() 함수는 HTTP 요청을 만드는 데 사용되며 요청에 대한 응답으로 확인되는 Promise를 반환합니다.

다음은 fetch() 함수를 사용하여 브라우저 내 스크립트에서 API의 데이터와 같은 외부 리소스를 가져오는 방법의 예입니다.

javascript

fetch('https://api.example.com/data') // Make a GET request to the specified URL
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not OK'); // Handle non-OK responses
    }
    return response.json(); // Parse the response as JSON and return the parsed data
  })
  .then(data => {
    console.log(data); // Use the fetched data
  })
  .catch(error => {
    console.error('Error fetching data:', error); // Handle any errors that may occur
  });
이 예제에서 fetch() 함수는 외부 리소스의 URL을 인수로 사용하여 호출됩니다. 이 함수는 요청에 대한 응답으로 확인되는 'Promise'를 반환합니다. 그런 다음 비동기 작업의 연결을 허용하는 then() 메서드를 사용하여 응답을 처리할 수 있습니다. 이 경우 먼저 응답 개체의 'ok' 속성을 사용하여 응답의 OK 상태를 확인합니다. 응답이 OK이면 json() 메서드가 호출되어 응답을 JSON으로 구문 분석하고 구문 분석된 데이터를 반환합니다. 마지막으로 가져온 데이터는 콘솔에 기록됩니다. 가져오기 작업 중에 발생할 수 있는 모든 오류는 적절한 오류 처리를 위해 catch() 블록을 사용하여 포착됩니다.
```
  * 브라우저의 `XMLHttpRequest` 객체는 무엇이고 어떻게 동작하나요?
  ```
  XMLHttpRequest 개체는 웹 브라우저 내에서 HTTP 요청을 만들 수 있는 내장 JavaScript 개체입니다. HTTP 또는 HTTPS 프로토콜을 통해 데이터를 송수신하기 위한 인터페이스를 제공하며 일반적으로 서버에서 데이터를 가져오거나 서버에 데이터를 제출하거나 다른 유형의 HTTP 통신을 수행하는 데 사용됩니다.
  
  다음은 XMLHttpRequest 개체가 작동하는 방식에 대한 높은 수준의 개요입니다.
  
  1. 인스턴스 만들기: const xhr = new XMLHttpRequest();와 같이 생성자를 호출하여 새 XMLHttpRequest 개체를 만들 수 있습니다.
  2. 요청 구성: XMLHttpRequest의 인스턴스를 생성한 후 개체에 대한 다양한 속성 및 메서드를 설정하여 요청을 구성할 수 있습니다. 예를 들어 HTTP 메서드(GET, POST, PUT, DELETE 등), 상호 작용하려는 리소스의 URL, 요청 헤더 및 요청 매개 변수를 설정할 수 있습니다.
  3. 요청 보내기: 요청이 구성되면 XMLHttpRequest 개체에서 open() 및 send() 메서드를 호출하여 보낼 수 있습니다. open() 메소드는 HTTP 메소드와 요청 URL을 지정하고 send() 메소드는 요청을 시작하고 필요한 경우 요청 데이터를 보냅니다.
  4. 응답 수신: 서버가 요청에 응답하면 XMLHttpRequest 개체는 요청 상태에 따라 load, progress, error, abort 등의 다양한 이벤트를 트리거합니다. 이벤트 리스너를 등록하여 이러한 이벤트를 처리하고 일반적으로 XMLHttpRequest 개체의 responseText 또는 responseXML 속성에서 사용할 수 있는 응답 데이터를 처리할 수 있습니다.
  5. 오류 처리: 서버에서 오류 상태 코드(예: 4xx 또는 5xx)를 반환하거나 요청에 다른 문제가 있는 경우 XMLHttpRequest 개체의 onerror 이벤트가 트리거되고 처리할 수 있습니다. 코드의 오류.
  6. 정리: 응답을 처리한 후 필요한 경우 XMLHttpRequest 객체를 닫고 사용했을 수 있는 모든 리소스를 해제하여 XMLHttpRequest 객체를 정리해야 합니다.
  ```
  * `fetch` API는 무엇이고 어떻게 동작하나요?
  ```
  'fetch' API는 웹 브라우저 내에서 서버에서 데이터를 가져오는 것과 같은 HTTP 요청을 만드는 쉽고 현대적인 방법을 제공하는 내장 JavaScript API입니다. 이전 XMLHttpRequest 개체에 비해 더 유연하고 강력하게 설계되었으며 요청에 대한 응답으로 해석되는 Promise를 반환하여 비동기 작업을 보다 효율적으로 처리할 수 있습니다.
  
  다음은 fetch API 작동 방식에 대한 대략적인 개요입니다.
  요청하기: 최신 웹 브라우저에서 사용할 수 있는 전역 함수인 fetch() 함수를 사용하여 HTTP 요청을 할 수 있습니다. fetch() 함수는 URL을 인수로 사용하고 URL에 있는 리소스를 가져오는 비동기 작업을 나타내는 Promise를 반환합니다.
  응답 처리: fetch() 함수는 요청에 대한 응답으로 해석되는 Promise를 반환합니다. 'then()' 메서드를 사용하여 작업을 연결하고 응답을 처리할 수 있습니다. 예를 들어 response.json()을 호출하여 응답 본문을 JSON으로 구문 분석하고 response.text()를 호출하여 응답 본문을 텍스트로 가져오거나 response.blob()을 호출하여 응답 본문을 다음과 같이 가져올 수 있습니다. 바이너리 블롭.
  오류 확인: fetch() 함수는 OK가 아닌(예: 4xx 또는 5xx) HTTP 상태 코드에 대해 Promise를 자동으로 거부하지 않습니다. 응답 객체의 ok 속성을 명시적으로 확인하거나 response.ok 부울 값을 사용하여 응답의 성공 여부를 결정해야 합니다. 또한 response.status 및 response.statusText 속성을 사용하여 각각 응답의 상태 코드 및 상태 텍스트를 가져올 수 있습니다.
  오류 처리: 서버가 오류 상태 코드를 반환하거나 요청에 다른 문제가 있는 경우 fetch()에서 반환된 Promise는 여전히 성공적으로 해결되지만 catch() 오류를 처리하기 위한  메서드 또는 catch 블록. 예를 들어 오류를 발생시키거나 오류 메시지를 기록하거나 기타 적절한 오류 처리 작업을 수행할 수 있습니다.
  정리: 응답을 처리한 후에는 항상 response 개체의 close() 메서드를 호출하여 리소스 누수를 방지하기 위해 네트워크 연결과 같은 응답과 관련된 모든 리소스를 해제해야 합니다.
  ```
* REST는 무엇인가요?
```
REST는 Representational State Transfer의 약자이며 네트워크 애플리케이션 설계에 사용되는 아키텍처 스타일입니다. REST는 확장 가능하고 효율적인 웹 서비스를 구축하는 데 일반적으로 사용되는 제약 조건 집합을 정의합니다.

웹 서비스 및 API(응용 프로그래밍 인터페이스) 컨텍스트에서 RESTful API는 World Wide Web의 기반인 HTTP 프로토콜과 함께 작동하도록 설계되었습니다. RESTful API는 GET, POST, PUT, PATCH 및 DELETE와 같은 표준 HTTP 메서드를 사용하여 일반적으로 URL(Uniform Resource Locator)로 표시되는 URI(Uniform Resource Identifier)로 식별되는 리소스에 대한 작업을 수행합니다.

RESTful API는 클라이언트(예: 웹 브라우저 또는 모바일 앱)가 서버에서 리소스를 요청하고 서버가 JSON(JavaScript Object Notation) 또는 XML(eXtensible Markup Language)과 같은 형식으로 요청된 데이터로 응답하는 클라이언트-서버 아키텍처를 따릅니다. . RESTful API는 stateless입니다. 즉, 클라이언트에서 서버로의 각 요청에는 요청을 이해하고 처리하는 데 필요한 모든 정보가 포함되어야 합니다. 서버는 요청 간에 클라이언트별 데이터를 저장하지 않으므로 RESTful API를 확장 가능하고 유지 관리하기 쉽습니다.

RESTful API는 단순하고 확장 가능하며 이해하기 쉽도록 설계되었습니다. 표준 HTTP 메서드와 상태 코드를 사용하여 원하는 작업과 요청 결과를 나타냅니다. 시스템의 엔터티를 나타내는 리소스는 URI로 식별되며 리소스에 대한 작업은 적절한 HTTP 메서드를 사용하여 수행됩니다. RESTful API는 웹을 통해 리소스에 액세스하고 조작하는 일관되고 일관된 방법을 제공하므로 다양한 애플리케이션 및 시스템용 웹 서비스 및 API를 구축하는 데 널리 사용됩니다.
```
  * REST API는 어떤 목적을 달성하기 위해 나왔고 어떤 장점을 가지고 있나요?
  ```
  RESTful API라고도 하는 REST(Representational State Transfer) API는 인터넷을 통해 서로 다른 소프트웨어 시스템 간의 통신 및 데이터 교환을 용이하게 하도록 설계된 API(응용 프로그래밍 인터페이스) 유형입니다. REST API의 주요 목적은 서버가 요청 간에 클라이언트 상태에 대한 정보를 저장하지 않는 상태 비저장 방식으로 클라이언트-서버 통신을 활성화하는 것입니다.
  REST API 사용의 이점은 다음과 같습니다.
  1. 확장성: REST API는 상태 비저장 클라이언트-서버 아키텍처를 기반으로 하므로 확장성이 뛰어나므로 필요에 따라 더 많은 서버를 추가하여 쉽게 수평적 확장이  가능합니다.
  2. 단순성: REST API는 경량 설계와 데이터 작업을 위한 GET, POST, PUT 및 DELETE와 같은 표준 HTTP 메서드 사용으로 인해 이해하고 구현하기 쉽습니다.
  3. 유연성: REST API는 XML, JSON 등과 같은 여러 데이터 형식을 지원하므로 다양한 클라이언트 및 플랫폼에 적응할 수 있습니다.
  4. 상호 운용성: REST API는 플랫폼 및 언어에 구애받지 않으므로 기본 기술 스택에 관계없이 서로 다른 소프트웨어 시스템이 서로 통신할 수 있습니다.
  5. 캐싱: REST API는 응답 캐싱을 지원하여 성능을 개선하고 서버의 부하를 줄일 수 있습니다.
  6. 보안: REST API는 OAuth, SSL/TLS 등과 같은 다양한 인증 및 권한 부여 메커니즘을 사용하여 보안을 유지하여 클라이언트와 서버 간의 안전한 통신을 보장할 수 있습니다.
  7. 테스트 가능성: REST API는 Postman과 같은 도구를 사용하여 쉽게 테스트할 수 있으므로 개발 중에 기능을 편리하게 확인하고 검증할 수 있습니다.
  전반적으로 REST API는 인터넷을 통해 서로 다른 소프트웨어 시스템 간의 통신 및 데이터 교환을 가능하게 하는 강력하고 확장 가능하며 유연한 방법을 제공하므로 최신 웹 및 모바일 애플리케이션에서 널리 사용됩니다.
  ```
  * RESTful한 API 설계의 단점은 무엇인가요?
  ```
  RESTful API에는 많은 장점이 있지만 잠재적인 단점도 있습니다.
  1. 유연성 부족: RESTful API는 특정 사용 사례에서 유연성을 제한할 수 있는 REST 원칙의 제약을 받습니다. 예를 들어 RESTful API는 실시간 애플리케이션이나 높은 수준의 사용자 지정 또는 복잡한 상호 작용이 필요한 상황에는 적합하지 않을 수 있습니다.
  2. 데이터의 과다 가져오기 또는 부족 가져오기: RESTful API는 때때로 필요한 것보다 더 많은 데이터를 반환하거나(과도하게 가져오기) 데이터가 충분하지 않아(과소 가져오기) 비효율적인 데이터 검색 또는 누락된 데이터를 가져오기 위한 추가 요청으로 이어질 수 있습니다. 성능에 영향을 미치고 네트워크 오버헤드를 증가시킬 수 있습니다.
  3. 버전 관리 문제: RESTful API가 발전함에 따라 API 엔드포인트 또는 데이터 모델에 대한 변경 사항에는 버전 관리가 필요할 수 있으며 이로 인해 이전 버전과의 호환성을 유지하고 다양한 버전의 API를 관리하는 데 문제가 발생할 수 있습니다.
  4. 표준화 부족: REST는 몇 가지 표준화된 원칙을 따르지만 RESTful API에 대한 엄격한 표준화가 없기 때문에 API 디자인, 문서 및 동작이 달라질 수 있으므로 개발자가 다른 API를 배우고 작업하는 것이 어려울 수 있습니다.
  5. 실시간 통신에 대한 제한된 지원: RESTful API는 주로 요청-응답 스타일의 상호 작용을 위해 설계되었으며 채팅과 같이 짧은 대기 시간, 양방향 통신이 필요한 실시간 통신 시나리오에는 적합하지 않을 수 있습니다. 응용 프로그램 또는 실시간 게임.
  6. 보안 문제: RESTful API는 인증 및 암호화와 같은 다양한 보안 메커니즘을 지원하지만 이러한 보안 조치를 구현하는 책임은 API 개발자에게 있습니다. 제대로 구현되지 않은 경우 RESTful API는 XSS(교차 사이트 스크립팅), CSRF(교차 사이트 요청 위조) 등과 같은 보안 위협에 취약할 수 있습니다.
  7. 검색 가능성 부족: RESTful API는 사용 가능한 리소스 및 작업을 검색하기 위한 기본 제공 메커니즘을 제공하지 않을 수 있습니다. 사용 가능한 엔드포인트 및 해당 기능을 이해하려면 추가 문서 또는 API 공급자와의 통신이 필요할 수 있습니다.
  이러한 단점에도 불구하고 RESTful API는 단순성, 확장성 및 상호 운용성으로 인해 계속 널리 사용됩니다. 그러나 RESTful API를 설계할 때 프로젝트의 특정 요구 사항을 신중하게 고려하고 개발 중인 애플리케이션의 요구 사항 및 제약 조건과 일치하는지 평가하는 것이 중요합니다.
  ```
* CORS란 무엇인가요? 이러한 기능이 왜 필요할까요? CORS는 어떻게 구현될까요?
```
CORS는 Cross-Origin Resource Sharing의 약자입니다. 원래 웹 페이지를 제공한 도메인이 아닌 다른 도메인에 대한 요청을 웹 페이지에서 제한하는 웹 브라우저에 구현된 보안 기능입니다. CORS는 웹 리소스에 대한 무단 액세스를 방지하고 XSS(교차 사이트 스크립팅) 및 CSRF(교차 사이트 요청 위조) 공격을 완화하는 보안 메커니즘입니다.

한 도메인(원본)에서 제공되는 웹 페이지는 일반적으로 요청된 리소스를 호스팅하는 서버가 응답의 CORS 헤더를 통해 이를 명시적으로 허용하지 않는 한 다른 도메인에 대한 XMLHttpRequest 또는 Fetch 요청을 할 수 없습니다. 이는 사용자 데이터를 보호하고 악의적인 웹 사이트가 사용자를 대신하여 다른 도메인에 무단 요청을 하는 것을 방지하기 위해 수행됩니다.

CORS 헤더는 서버 측에서 구현되며 웹 리소스를 호스팅하는 서버의 HTTP 응답에 포함됩니다. 이러한 헤더에는 리소스에 액세스할 수 있는 허용된 출처, HTTP 메서드, 헤더 및 자격 증명과 같은 정보가 포함됩니다. 가장 일반적으로 사용되는 CORS 헤더는 다음과 같습니다.

Access-Control-Allow-Origin: 리소스에 액세스할 수 있는 원본 또는 원본을 지정합니다. 이는 특정 출처, "*"로 설정하여 모든 출처 또는 허용된 출처 목록을 허용할 수 있습니다.
Access-Control-Allow-Methods: 리소스에 요청할 때 사용할 수 있는 HTTP 메서드를 지정합니다.
Access-Control-Allow-Headers: 요청에 포함될 수 있는 헤더를 지정합니다.
'Access-Control-Allow-Credentials': 쿠키 또는 HTTP 인증과 같은 자격 증명이 요청에 포함될 수 있는지 여부를 나타냅니다.
Access-Control-Max-Age: 실행 전 요청(OPTIONS)이 브라우저에 의해 캐시되어야 하는 최대 시간(초)을 지정합니다.

CORS는 웹 페이지와 서버 간의 보안 교차 출처 통신을 가능하게 하여 웹 사이트가 사용자 데이터를 보호하고 무단 액세스를 방지하면서 다른 도메인에서 리소스를 가져올 수 있도록 하기 때문에 중요합니다. 이는 웹 브라우저에서 동일 출처 정책을 시행하는 데 도움이 되며 서버가 필요할 때 교차 출처 요청을 명시적으로 허용하는 메커니즘을 제공합니다. CORS를 구현하려면 웹 리소스를 호스팅하는 서버의 HTTP 응답에 적절한 CORS 헤더를 설정하고 클라이언트 측 코드가 웹 브라우저의 CORS 제한 사항을 준수하는지 확인해야 합니다.
```

## Quest
* 이번 퀘스트는 Midterm에 해당하는 과제입니다. 분량이 제법 많으니 한 번 기능별로 세부 일정을 정해 보고, 과제 완수 후에 그 일정이 얼마나 지켜졌는지 스스로 한 번 돌아보세요.
  * 이번 퀘스트부터는 skeleton을 제공하지 않습니다!
* Quest 05에서 만든 메모장 시스템을 서버와 연동하는 어플리케이션으로 만들어 보겠습니다.
  * 클라이언트는 `fetch` API를 통해 서버와 통신합니다.
  * 서버는 8000번 포트에 REST API를 엔드포인트로 제공하여, 클라이언트의 요청에 응답합니다.
  * 클라이언트로부터 온 새 파일 저장, 삭제, 다른 이름으로 저장 등의 요청을 받아 서버의 로컬 파일시스템을 통해 저장되어야 합니다.
    * 서버에 어떤 식으로 저장하는 것이 좋을까요?
  * API 서버 외에, 클라이언트를 띄우기 위한 서버가 3000번 포트로 따로 떠서 API 서버와 서로 통신할 수 있어야 합니다.
  * Express나 Fastify 등의 프레임워크를 사용해도 무방합니다.
* 클라이언트 프로젝트와 서버 프로젝트 모두 `npm i`만으로 디펜던시를 설치하고 바로 실행될 수 있게 제출되어야 합니다.
* 이번 퀘스트부터는 앞의 퀘스트의 결과물에 의존적인 경우가 많습니다. 제출 폴더를 직접 만들어 제출해 보세요!

## Advanced
* `fetch` API는 구현할 수 없지만 `XMLHttpRequest`로는 구현할 수 있는 기능이 있을까요?
* REST 이전에는 HTTP API에 어떤 패러다임들이 있었을까요? REST의 대안으로는 어떤 것들이 제시되고 있을까요?
