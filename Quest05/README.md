# Quest 05. OOP 특훈

## Introduction
* 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍을 조금 더 훈련해 보겠습니다.

## Topics
* Separation of Concerns
* 객체지향의 설계 원칙
  * SOLID 원칙
* Local Storage

## Resources
* [Separation of concerns](https://jonbellah.com/articles/separation-of-concerns/)
* [SOLID](https://en.wikipedia.org/wiki/SOLID)
* [객체지향 설계 5원칙](https://webdoli.tistory.com/210)
* [MDN - Local Storage](https://developer.mozilla.org/ko/docs/Web/API/Window/localStorage)

## Checklist
* 관심사의 분리 원칙이란 무엇인가요? 웹에서는 이러한 원칙이 어떻게 적용되나요?
관심사의 분리(Separation of Concerns, SoC) 원칙은 소프트웨어 설계의 일반적인 원칙 중 하나로, 각각의 컴포넌트나 모듈이 자신의 역할에 집중하고, 다른 컴포넌트와 가능한 적은 결합도를 가지도록 설계하는 것입니다. 즉, 서로 다른 관심사를 가진 부분들을 서로 분리하여 각 부분을 독립적으로 변경할 수 있도록 만드는 것입니다.

웹에서는 관심사의 분리 원칙을 다양한 방식으로 적용할 수 있습니다. 예를 들어, HTML은 문서의 구조를 정의하고, CSS는 문서의 스타일을 지정하며, JavaScript는 문서의 동작을 구현하는 등 각각의 역할에 맞추어 분리되어 있습니다. 또한, MVC(Model-View-Controller) 패턴을 적용하여, 데이터 모델, UI, 비즈니스 로직 등 서로 다른 관심사를 분리하여 개발할 수 있습니다. 또한, 모듈화를 통해 코드를 관심사 단위로 분리하여 유지보수성을 향상시킬 수 있습니다. 이러한 방식으로 웹에서 관심사의 분리 원칙을 적용하면 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

* 객체지향의 SOLID 원칙이란 무엇인가요? 이 원칙을 구체적인 예를 들어 설명할 수 있나요?
S (SRP: Single Responsibility Principle) : 단일 책임 원칙
O (OCP: Open/Closed Principle) : 개방-폐쇄 원칙
L (LSP: Liskov Substitution Principle) : 리스코프 치환 원칙
I (ISP: Interface Segregation Principle) : 인터페이스 분리 원칙
D (DIP: Dependency Inversion Principle) : 의존성 역전 원칙
단일 책임 원칙의 예: 하나의 클래스는 하나의 책임(기능)만 가져야 한다는 원칙.
Because 하나의 클래스에 여러가지 기능들을 넣을 시 업데이트가 필요할 때 이미 여러곳에서 그 클래스를 사용하고 있다면 예기치 않은 오류가 발생 할 수 있음.
각각의 클래스가 단순하고 응집력 있게 유지되어 유지보수성 기능 향상됨.
https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-SRP-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99 참조

개방-폐쇄의 원칙의 예:기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계
OCP를 확장에 대해서는 개방적(open)이고, 수정에 대해서는 폐쇄적(closed)이어야 한다는 의미.
https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-OCP-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99 참조

리스코프 치원 원칙의 예: 서브타입은 언제나 기반 타입으로 교체할 수 있어야한다.
교체할 수 있다는 말은,자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행이 보장되어야 한다는 뜻.
부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다는 의미.
LSP 원칙 위반은 자식 클래스가 오버라이딩을 할 때, 잘못되게 재정의 하면 LSP 원칙을 위배할 수 있다는 의미.
자식 클래스가 오버라이딩을 잘못하는 경우는 크게 2가지로 나뉜다.
1.부모의 의도와 다르게 메소드 오버라이딩
2.잘못된 상속 관계 구성으로 인한 메서드 정의
https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-LSP-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99 참조

인터페이스 분리 원칙의 예:인터페이스를 사용에 맞게 끔 각기 분리해야한다는 원칙.
인터페이스를 잘게 분리함으로써 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공.
SRP와 거의 유사하다고 보면 된다. SRP는 클래스의 단일 책임이면 ISP는 인터페이스의 단일 책임 강조.
인터페이스를 분리하는 기준은 상황에 따라 다르다. 핵심은 관련 있는 기능끼리 하나의 인터페이스에 모으되 지나치게 커지지 않게 크기를 제한하라는 점.
주의 할 점. 한번 인터페이스를 분리하여 구성해놓고 나중에 수정사항이 생겨 또 인터페이스를 분리하는 행위는 X.
인터페이스는 한번 구성하였으면 왠만해선 변하면 안되는 정책같은 개념.
https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-ISP-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99 참조

의존성 역천 원칙의 예: 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙.
객체들이 서로 정보를 주고 받을 떄는 의존 관계가 형성되는데, 이 때 객체들은 나름대로의 원칙을 갖고 정보를 주고 받아야하는 약속이 있다. 나름대로의 원칙이란 추상성이 낮은 클래스보다 추상성이 높은 클래스와 통신을 한다는것을 의미 이것이 DIP 원칙.
왜 그렇게 하느냐? 하위 모듈에 구체적인 내용에 클라이언트가 의존시 하위 모듈에 변화가 있을 떄마다 클라이언트나 상위 모듈의 코드를 자주 수정해야하기 때문.
한마디로 정의시 "상위의 인터페이스 타입의 객체로 통신".
DIP 원칙 위반 예제
게임을 예로 들면 여러가지 무기들을 장착하는 캐릭터가 있는데, 캐릭터 클래스가 인스턴스화 될 때에 캐릭터 이름과 체력 그리고 장착하는 무기를 입력값으로 받아 초기화하고 캐릭터 클래스내에 필드 변수로서 클래스탑의 변수를 저장해놓고, 공격 매서드를 수행하면 무기 클래스의 메서드가 실행되어 데미지가 가하는 형태.
즉, 캐릭터 인스턴스 생성 시 무기종류에 의존성을 가지게되어, 공격 메소드 역시 무기 종류에 의존성을 가지게 된다.
https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-DIP-%EC%9D%98%EC%A1%B4-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99 참조

* 로컬 스토리지란 무엇인가요? 로컬 스토리지의 내용을 개발자 도구를 이용해 확인하려면 어떻게 해야 할까요?
로컬 스토리지(Local Storage)는 HTML5에서 제공하는 웹 브라우저의 저장소입니다. 로컬 스토리지는 사용자가 웹 페이지를 방문하면 해당 웹 사이트에서 저장한 데이터를 브라우저에 저장할 수 있게 해줍니다.

로컬 스토리지는 세션 스토리지(Session Storage)와 마찬가지로 키-값 쌍으로 데이터를 저장합니다. 하지만 세션 스토리지는 브라우저 세션이 종료되면 데이터가 삭제되지만, 로컬 스토리지는 사용자가 명시적으로 데이터를 삭제하지 않는 한 영구적으로 데이터를 보존합니다.

로컬 스토리지의 내용을 개발자 도구를 이용해 확인하려면 브라우저의 개발자 도구를 열고, Application 탭으로 이동해야 합니다. 그리고 왼쪽 패널에서 Storage 항목을 선택하면 로컬 스토리지의 내용을 확인할 수 있습니다. 각 웹 사이트마다 로컬 스토리지에 저장한 데이터가 분리되어 저장되므로, 왼쪽 패널에서 해당 웹 사이트의 도메인을 선택해야 합니다. 선택한 도메인의 오른쪽 패널에서 로컬 스토리지에 저장된 키-값 쌍의 목록과 값을 확인할 수 있습니다. 또한 개발자 도구 콘솔에서도 로컬 스토리지의 내용을 확인하고 조작할 수 있습니다.

## Quest
* 외부 라이브러리나 프레임워크를 사용하지 않고, 자바스크립트를 이용하여 간단한 웹브라우저 기반의 텍스트 에디터를 만들어 보겠습니다.
  * 기본적으로 VSCode와 같이 탭을 이용해 여러 개의 파일을 동시에 편집할 수 있습니다.
  * 탭을 눌러 열려 있는 다른 파일을 편집할 수 있으며 탭을 언제든지 닫을 수 있습니다.
  * VSCode와 같이 새 파일, 로드, 저장, 다른 이름으로 저장 등의 기능을 가집니다. 저장은 웹 브라우저의 로컬 스토리지를 이용합니다.
  * VSCode와 같이 탭이 수정되었는데 저장되기 이전일 경우 이를 알려주는 인디케이터가 작동합니다.
  * 같은 이름의 파일을 저장할 경우 에러를 표시해야 합니다.
* 이번 퀘스트의 결과물은 앞으로의 많은 퀘스트에서 재사용되게 되니, 주의깊게 코드를 작성해 보세요!

## Advanced
* 웹 프론트엔드 개발에서 이러한 방식의 패턴을 더 일반화해서 정리할 수 있을까요? 이 퀘스트에서 각각의 클래스들이 공통적으로 수행하게 되는 일들에는 무엇이 있을까요?
